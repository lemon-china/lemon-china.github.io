<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lemon-china</title>
  
  <subtitle>乐檬·中国致力于打造最优雅的系统框架</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/lemon-china/"/>
  <updated>2019-09-07T13:38:59.821Z</updated>
  <id>https://github.com/lemon-china/</id>
  
  <author>
    <name>lemon-china</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>乐檬框架之cloud微服务框架</title>
    <link href="https://github.com/lemon-china/2019/09/06/doc_1112/"/>
    <id>https://github.com/lemon-china/2019/09/06/doc_1112/</id>
    <published>2019-09-06T10:34:12.000Z</published>
    <updated>2019-09-07T13:38:59.821Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于consul注册中心实现微服务框架，使用consul替代eureka和git config模式</p></blockquote><p>项目地址：<a href="https://github.com/lemon-china/lemon-consul-cloud">lemon-consul-cloud</a></p><p>本项目预启动时间为2019-03-01，实现以下内容：</p><h4 id="开发计划"><a href="#开发计划" class="headerlink" title="开发计划"></a>开发计划</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v0.1版本 整体服务结构划分，服务边界设定</span><br><span class="line">v0.2版本 服务网关授权模式搭建</span><br><span class="line">v0.3版本 前后端技术框架接入</span><br><span class="line">v0.4版本 服务开发技术规范文档</span><br><span class="line">v0.5版本 用户基础服务功能</span><br></pre></td></tr></table></figure><h4 id="服务框架总览"><a href="#服务框架总览" class="headerlink" title="服务框架总览"></a>服务框架总览</h4><p>— lemon-gateway  服务网关<br>— lemon-monitor  服务监控</p><p>commons  服务基础组件中心<br>— lemon-common  服务通用组件<br>— lemon-distribution  分布业务锁&amp;任务锁<br>— lemon-framework  服务基础功能类包<br>— lemon-rabbit  服务Rabbit功能统一封装组件<br>— lemon-sharding  数据库分库分表封装组件</p><p>services  微服务中心<br>— lemon-auth  授权&amp;鉴权服务<br>— lemon-user  用户服务<br>— lemon-xxx   </p><h4 id="服务划分说明"><a href="#服务划分说明" class="headerlink" title="服务划分说明"></a>服务划分说明</h4><p><em>明确划分每个服务的功能</em></p><table><thead><tr><th>NO.</th><th>Module</th><th>Name</th><th>Desc</th></tr></thead><tbody><tr><td>1</td><td>lemon-auth</td><td>授权服务</td><td>用户授权中心管理</td></tr><tr><td>2</td><td>lemon-user</td><td>用户服务</td><td>用户信息中心服务</td></tr><tr><td>3</td><td>lemon-payment</td><td>账务服务</td><td>用户交易中心服务</td></tr><tr><td>4</td><td>lemon-adjust</td><td>核算服务</td><td>账户核算中心服务</td></tr><tr><td>5</td><td>lemon-message</td><td>消息服务</td><td>用户消息中心服务</td></tr></tbody></table><h4 id="服务项目结构约定"><a href="#服务项目结构约定" class="headerlink" title="服务项目结构约定"></a>服务项目结构约定</h4><table><thead><tr><th>NO.</th><th>Package</th><th>Desc</th></tr></thead><tbody><tr><td>1</td><td>cn.lemon.{xxxx}.api.rest</td><td>提供对外服务rest接口</td></tr><tr><td>2</td><td>cn.lemon.{xxxx}.api.rpc</td><td>提供对内服务rpc接口</td></tr><tr><td>3</td><td>cn.lemon.{xxxx}.config</td><td>提供服务配置相关</td></tr><tr><td>4</td><td>cn.lemon.{xxxx}.entity.enums</td><td>提供业务枚举类</td></tr><tr><td>5</td><td>cn.lemon.{xxxx}.entity.po</td><td>提供数据库映射实体</td></tr><tr><td>6</td><td>cn.lemon.{xxxx}.entity.vo</td><td>提供对外接口映射实体</td></tr><tr><td>7</td><td>cn.lemon.{xxxx}.rpc.client</td><td>提供对内服务rpc调用接口 (api层不能调用rpc接口)</td></tr><tr><td>8</td><td>cn.lemon.{xxxx}.rpc.client.fallback</td><td>提供对内服务rpc调用失败业务处理</td></tr><tr><td>9</td><td>cn.lemon.{xxxx}.service</td><td>提供业务逻辑接口 (api层调用业务接口)</td></tr><tr><td>10</td><td>cn.lemon.{xxxx}.service.impl</td><td>提供业务逻辑实现</td></tr><tr><td>11</td><td>cn.lemon.{xxxx}.dao</td><td>提供数据库操作</td></tr><tr><td>12</td><td>cn.lemon.{xxxx}.events.pub</td><td>提供MQ发送事件</td></tr><tr><td>13</td><td>cn.lemon.{xxxx}.events.sub</td><td>提供MQ接收事件</td></tr><tr><td>14</td><td>cn.lemon.{xxxx}.task</td><td>提供任务定时执行逻辑</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于consul注册中心实现微服务框架，使用consul替代eureka和git config模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/lemon-china/lemon-co
      
    
    </summary>
    
    
      <category term="开源文档" scheme="https://github.com/lemon-china/categories/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="cloud" scheme="https://github.com/lemon-china/tags/cloud/"/>
    
      <category term="springboot" scheme="https://github.com/lemon-china/tags/springboot/"/>
    
      <category term="consul" scheme="https://github.com/lemon-china/tags/consul/"/>
    
      <category term="lemon" scheme="https://github.com/lemon-china/tags/lemon/"/>
    
  </entry>
  
  <entry>
    <title>服务开发核心思想</title>
    <link href="https://github.com/lemon-china/2019/09/05/exp_1113/"/>
    <id>https://github.com/lemon-china/2019/09/05/exp_1113/</id>
    <published>2019-09-05T04:30:12.000Z</published>
    <updated>2019-09-07T11:38:52.865Z</updated>
    
    <content type="html"><![CDATA[<h3 id="保障服务可扩展性的七大原则"><a href="#保障服务可扩展性的七大原则" class="headerlink" title="保障服务可扩展性的七大原则"></a>保障服务可扩展性的七大原则</h3><p>1、按功能划分</p><p>2、水平切分</p><p>3、尽量避免事务</p><p>4、适当采用异步解耦</p><p>5、次流程改进为异步</p><p>6、虚拟化所有层次</p><p>7、适当使用缓存</p><h3 id="服务拆分开发的四项原则"><a href="#服务拆分开发的四项原则" class="headerlink" title="服务拆分开发的四项原则"></a>服务拆分开发的四项原则</h3><p>1、先业务后技术，先逻辑后物理</p><p>2、奥卡姆剃刀：如无必须勿增实体</p><p>3、正交性：抽象出模块间无业务相关的重复代码</p><p>4、稳定性原则：服务的稳定性优先，通过拆分解耦</p><blockquote><p>可参考的技术方案：接口化、消息队列、模块化、服务化、异步化</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;保障服务可扩展性的七大原则&quot;&gt;&lt;a href=&quot;#保障服务可扩展性的七大原则&quot; class=&quot;headerlink&quot; title=&quot;保障服务可扩展性的七大原则&quot;&gt;&lt;/a&gt;保障服务可扩展性的七大原则&lt;/h3&gt;&lt;p&gt;1、按功能划分&lt;/p&gt;
&lt;p&gt;2、水平切分&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="经验分享" scheme="https://github.com/lemon-china/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="cloud" scheme="https://github.com/lemon-china/tags/cloud/"/>
    
      <category term="springboot" scheme="https://github.com/lemon-china/tags/springboot/"/>
    
      <category term="分布式" scheme="https://github.com/lemon-china/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>XXL-JOB分布式任务快速入门</title>
    <link href="https://github.com/lemon-china/2019/09/04/stu_1111/"/>
    <id>https://github.com/lemon-china/2019/09/04/stu_1111/</id>
    <published>2019-09-04T07:21:11.000Z</published>
    <updated>2019-09-07T13:07:34.938Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。</p></blockquote><p>项目地址：<a href="http://www.xuxueli.com/xxl-job/" target="_blank" rel="noopener">xxl-job分布式任务调度平台</a></p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li>调度中心 xxl-job-admin</li><li>公共依赖 xxl-job-core</li><li>任务执行器 opay-xxx</li></ul><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><ul><li>调度中心集群</li><li>DB配置保持一致</li><li>登陆账号配置保持一致</li><li>集群机器时钟保持一致<br><em>建议：推荐通过nginx为调度中心集群做负载均衡，分配域名</em></li><li>调度中心访问、执行器回调配置、调用API服务等操作均通过该域名进行。</li><li>执行器集群<ul><li>执行器回调地址保持一致<br><em>xxl.job.admin.addresses</em></li><li>执行器集群内AppName保持一致<br><em>xxl.job.executor.appname​</em></li></ul></li></ul><h3 id="任务关键点"><a href="#任务关键点" class="headerlink" title="任务关键点"></a>任务关键点</h3><ul><li>执行器</li><li>任务描述</li><li>路由策略<ul><li>FIRST（第一个）<br><em>固定选择第一个机器</em></li><li>LAST（最后一个）<br><em>固定选择最后一个机器</em></li><li>ROUND（轮询）</li><li>RANDOM（随机）<br><em>随机选择在线的机器</em></li><li>CONSISTENT_HASH（一致性HASH）<br><em>每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上</em></li><li>LEAST_FREQUENTLY_USED（最不经常使用）<br><em>使用频率最低的机器优先被选举</em></li><li>LEAST_RECENTLY_USED（最近最久未使用）<br><em>最久为使用的机器优先被选举</em></li><li>FAILOVER（故障转移）<br><em>按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度</em></li><li>BUSYOVER（忙碌转移）<br><em>按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度</em></li><li>SHARDING_BROADCAST(分片广播)<br><em>广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数，可根据分片参数开发分片任务</em> </li></ul></li><li>Cron表达式<ul><li>运行模式<ul><li>BEAN</li><li>GLUE</li><li>JobHandler<br><em>任务bean名称@JobHandler</em></li></ul></li></ul></li><li>阻塞策略<ul><li>单机串行<br><em>进入单机执行器后，进入FIFO队列并以串行方式运行</em></li><li>丢弃后续调度<br><em>进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败</em></li><li>覆盖之前调度<br><em>进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列</em></li></ul></li><li>负责人</li><li>其他<ul><li>子任务ID</li><li>超时时间</li><li>重试次数</li><li>报警邮件</li><li>任务参数</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>日志文件目录需要权限<br><em>默认 /data/applogs/xxl-job/jobhandler​</em></li><li>设置日志保存天数<br><em>xxl.job.executor.logretentiondays=-1 //大于3生效</em></li><li>执行日志需要通过 “XxlJobLogger.log” 打印执行日志</li><li>admin执行任务时报错 Communications link failure<br><em>数据库链接地址加上 &amp;autoReconnect=true&amp;failOverReadOnly=false</em></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;http://www.xux
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://github.com/lemon-china/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="https://github.com/lemon-china/tags/java/"/>
    
      <category term="开源工具" scheme="https://github.com/lemon-china/tags/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    
      <category term="定时任务" scheme="https://github.com/lemon-china/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>XXL-JOB分布式任务调度平台</title>
    <link href="https://github.com/lemon-china/2019/09/03/tool_1112/"/>
    <id>https://github.com/lemon-china/2019/09/03/tool_1112/</id>
    <published>2019-09-03T05:23:12.000Z</published>
    <updated>2019-09-07T13:07:38.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。</p></blockquote><p>项目地址：<a href="http://www.xuxueli.com/xxl-job/" target="_blank" rel="noopener">xxl-job分布式任务调度平台</a></p><ul><li>简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手；</li><li>动态：支持动态修改任务状态、启动/停止任务，以及终止运行中任务，即时生效；</li><li>调度中心HA（中心式）：调度采用中心式设计，“调度中心”自研调度组件并支持集群部署，可保证调度中心HA；</li><li>执行器HA（分布式）：任务分布式执行，任务”执行器”支持集群部署，可保证任务执行HA；</li><li>注册中心: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址；</li><li>弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务；</li><li>路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；</li><li>故障转移：任务路由策略选择”故障转移”情况下，如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求。</li><li>阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度；</li><li>任务超时控制：支持自定义任务超时时间，任务运行超时将会主动中断任务；</li><li>任务失败重试：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；其中分片任务支持分片粒度的失败重试；</li><li>任务失败告警；默认提供邮件方式失败告警，同时预留扩展接口，可方便的扩展短信、钉钉等告警方式；</li><li>分片广播任务：执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务；</li><li>动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。</li><li>事件触发：除了”Cron方式”和”任务依赖方式”触发任务执行之外，支持基于事件的触发任务方式。调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发。</li><li>任务进度监控：支持实时监控任务进度；</li><li>Rolling实时日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志；</li><li>GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。</li><li>脚本任务：支持以GLUE模式开发和运行脚本任务，包括Shell、Python、NodeJS、PHP、PowerShell等类型脚本;</li><li>命令行任务：原生提供通用命令行任务Handler（Bean任务，”CommandJobHandler”）；业务方只需要提供命令行即可；</li><li>任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行, 多个子任务用逗号分隔；</li><li>一致性：“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；</li><li>自定义任务参数：支持在线配置调度任务入参，即时生效；</li><li>调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞；</li><li>数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性；</li><li>邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件；</li><li>推送maven中央仓库: 将会把最新稳定版推送到maven中央仓库, 方便用户接入和使用;</li><li>运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等；</li><li>全异步：任务调度流程全异步化设计实现，如异步调度、异步运行、异步回调等，有效对密集调度进行流量削峰，理论上支持任意时长任务的运行；</li><li>跨平台：原生提供通用HTTP任务Handler（Bean任务，”HttpJobHandler”）；业务方只需要提供HTTP链接即可，不限制语言、平台；</li><li>国际化：调度中心支持国际化设置，提供中文、英文两种可选语言，默认为中文；</li><li>容器化：提供官方docker镜像，并实时更新推送dockerhub，进一步实现产品开箱即用；</li><li>线程池隔离：调度线程池进行隔离拆分，慢任务自动降级进入”Slow”线程池，避免耗尽调度线程，提高系统稳定性；</li><li>用户管理：支持在线管理系统用户，存在管理员、普通用户两种角色；</li><li>权限控制：执行器维度进行权限控制，管理员拥有全量权限，普通用户需要分配执行器权限后才允许相关操作。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;http://www.xux
      
    
    </summary>
    
    
      <category term="常用工具" scheme="https://github.com/lemon-china/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="java" scheme="https://github.com/lemon-china/tags/java/"/>
    
      <category term="开源工具" scheme="https://github.com/lemon-china/tags/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    
      <category term="定时任务" scheme="https://github.com/lemon-china/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码习惯在细节</title>
    <link href="https://github.com/lemon-china/2019/09/02/exp_1112/"/>
    <id>https://github.com/lemon-china/2019/09/02/exp_1112/</id>
    <published>2019-09-02T07:12:12.000Z</published>
    <updated>2019-09-07T07:38:18.422Z</updated>
    
    <content type="html"><![CDATA[<p>分布式服务框架维护人员增多或变更，会出现质量的下降的问题，尤其是框架代码，要时刻牢记的细节。可能下面要讲的这些，大家都会觉得很简单，很基础，但要做到时刻牢记。在每一行代码中都考虑这些因素，是需要很大耐心的。</p><h3 id="防止空指针和下标越界"><a href="#防止空指针和下标越界" class="headerlink" title="防止空指针和下标越界"></a>防止空指针和下标越界</h3><p>这是我最不喜欢看到的异常，尤其在核心框架中，我更愿看到信息详细的参数不合法异常。这也是一个编写健壮程序的开发人员，在写每一行代码都应在潜意识中防止的异常。基本上要能确保每一次写完的代码，在不测试的情况下，都不会出现这两个异常才算合格。</p><h3 id="保证线程安全性和可见性"><a href="#保证线程安全性和可见性" class="headerlink" title="保证线程安全性和可见性"></a>保证线程安全性和可见性</h3><p>对于框架的开发人员，对线程安全性和可见性的深入理解是最基本的要求。需要开发人员，在写每一行代码时都应在潜意识中确保其正确性。因为这种代码，在小并发下做功能测试时，会显得很正常。但在高并发下就会出现莫明其妙的问题，而且场景很难重现，极难排查。</p><h3 id="尽早失败和前置断言"><a href="#尽早失败和前置断言" class="headerlink" title="尽早失败和前置断言"></a>尽早失败和前置断言</h3><p>尽早失败也应该成为潜意识，在有传入参数和状态变化时，均在入口处全部断言。一个不合法的值和状态，在第一时间就应报错，而不是等到要用时才报错。因为等到要用时，可能前面已经修改其它相关状态，而在程序中很少有人去处理回滚逻辑。这样报错后，其实内部状态可能已经混乱，极易在一个隐蔽分支上引发程序不可恢复。</p><h3 id="分离可靠操作和不可靠操作"><a href="#分离可靠操作和不可靠操作" class="headerlink" title="分离可靠操作和不可靠操作"></a>分离可靠操作和不可靠操作</h3><p>这里的可靠是狭义的指是否会抛出异常或引起状态不一致，比如，写入一个线程安全的 Map，可以认为是可靠的，而写入数据库等，可以认为是不可靠的。开发人员必须在写每一行代码时，都注意它的可靠性与否，在代码中尽量划分开，并对失败做异常处理，并为容错，自我保护，自动恢复或切换等补偿逻辑提供清晰的切入点，保证后续增加的代码不至于放错位置，而导致原先的容错处理陷入混乱。</p><h3 id="异常防御，但不忽略异常"><a href="#异常防御，但不忽略异常" class="headerlink" title="异常防御，但不忽略异常"></a>异常防御，但不忽略异常</h3><p>这里讲的异常防御，指的是对非必须途径上的代码进行最大限度的容忍，包括程序上的 BUG，比如：获取程序的版本号，会通过扫描 Manifest 和 jar 包名称抓取版本号，这个逻辑是辅助性的，但代码却不少，初步测试也没啥问题，但应该在整个 getVersion() 中加上一个全函数的 try-catch 打印错误日志，并返回基本版本，因为 getVersion() 可能存在未知特定场景异常，或被其他的开发人员误修改逻辑(但一般人员不会去掉 try-catch)，而如果它抛出异常会导致主流程异常，这是我们不希望看到的。但这里要控制个度，不要随意 try-catch，更不要无声无息的吃掉异常。</p><h3 id="缩小可变域和尽量-final"><a href="#缩小可变域和尽量-final" class="headerlink" title="缩小可变域和尽量 final"></a>缩小可变域和尽量 final</h3><p>如果一个类可以成为不变类(Immutable Class)，就优先将它设计成不变类。不变类有天然的并发共享优势，减少同步或复制，而且可以有效帮忙分析线程安全的范围。就算是可变类，对于从构造函数传入的引用，在类中持有时，最好将字段 final，以免被中途误修改引用。不要以为这个字段是私有的，这个类的代码都是我自己写的，不会出现对这个字段的重新赋值。要考虑的一个因素是，这个代码可能被其他人修改，他不知道你的这个弱约定，final 就是一个不变契约。</p><h3 id="降低修改时的误解性，不埋雷"><a href="#降低修改时的误解性，不埋雷" class="headerlink" title="降低修改时的误解性，不埋雷"></a>降低修改时的误解性，不埋雷</h3><p>前面不停的提到代码被其他人修改，这也开发人员要随时紧记的。这个其他人包括未来的自己，你要总想着这个代码可能会有人去改它。我应该给修改的人一点什么提示，让他知道我现在的设计意图，而不要在程序里面加潜规则，或埋一些容易忽视的雷，比如：你用 null 表示不可用，size 等于 0 表示黑名单，这就是一个雷，下一个修改者，包括你自己，都不会记得有这样的约定，可能后面为了改某个其它 BUG，不小心改到了这里，直接引爆故障。对于这个例子，一个原则就是永远不要区分 null 引用和 empty 值。</p><h3 id="提高代码的可测性"><a href="#提高代码的可测性" class="headerlink" title="提高代码的可测性"></a>提高代码的可测性</h3><p>这里的可测性主要指 Mock 的容易程度，和测试的隔离性。至于测试的自动性，可重复性，非偶然性，无序性，完备性(全覆盖)，轻量性(可快速执行)，一般开发人员，加上 JUnit 等工具的辅助基本都能做到，也能理解它的好处，只是工作量问题。这里要特别强调的是测试用例的单一性(只测目标类本身)和隔离性(不传染失败)。现在的测试代码，过于强调完备性，大量重复交叉测试，看起来没啥坏处，但测试代码越多，维护代价越高。经常出现的问题是，修改一行代码或加一个判断条件，引起 100 多个测试用例不通过。时间一紧，谁有这个闲功夫去改这么多形态各异的测试用例？久而久之，这个测试代码就已经不能真实反应代码现在的状况，很多时候会被迫绕过。最好的情况是，修改一行代码，有且只有一行测试代码不通过。如果修改了代码而测试用例还能通过，那也不行，表示测试没有覆盖到。另外，可 Mock 性是隔离的基础，把间接依赖的逻辑屏蔽掉。可 Mock 性的一个最大的杀手就是静态方法，尽量少用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分布式服务框架维护人员增多或变更，会出现质量的下降的问题，尤其是框架代码，要时刻牢记的细节。可能下面要讲的这些，大家都会觉得很简单，很基础，但要做到时刻牢记。在每一行代码中都考虑这些因素，是需要很大耐心的。&lt;/p&gt;
&lt;h3 id=&quot;防止空指针和下标越界&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="经验分享" scheme="https://github.com/lemon-china/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="cloud" scheme="https://github.com/lemon-china/tags/cloud/"/>
    
      <category term="springboot" scheme="https://github.com/lemon-china/tags/springboot/"/>
    
      <category term="分布式" scheme="https://github.com/lemon-china/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Apollo分布式配置中心快速入门</title>
    <link href="https://github.com/lemon-china/2019/09/02/stu_1112/"/>
    <id>https://github.com/lemon-china/2019/09/02/stu_1112/</id>
    <published>2019-09-02T04:21:22.000Z</published>
    <updated>2019-09-07T13:31:36.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</p></blockquote><p>项目地址：<a href="https://github.com/ctripcorp/apollo">apollo分布式配置中心</a></p><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><ul><li>AppId</li><li>ENV</li><li>Cluster</li><li>Namespace<ul><li>Public</li><li>Private</li><li>关联(继承)</li></ul></li></ul><h2 id="操作点"><a href="#操作点" class="headerlink" title="操作点"></a>操作点</h2><ul><li>发布</li><li>回滚</li><li>灰度</li><li>创建Cluster</li><li>创建/关联Namespace</li></ul><h2 id="核心点"><a href="#核心点" class="headerlink" title="核心点"></a>核心点</h2><ul><li>项目AppId</li><li>宿主机ENV</li><li>apollo.meta</li><li>Private <em>AppId</em></li><li>Public <em>Share</em></li><li>可多Namespace</li><li>Public关联 / 覆盖</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目地址
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://github.com/lemon-china/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="https://github.com/lemon-china/tags/java/"/>
    
      <category term="开源工具" scheme="https://github.com/lemon-china/tags/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    
      <category term="定时任务" scheme="https://github.com/lemon-china/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="apollo" scheme="https://github.com/lemon-china/tags/apollo/"/>
    
  </entry>
  
  <entry>
    <title>乐檬框架之rabbitMQ的解耦实现方式</title>
    <link href="https://github.com/lemon-china/2019/09/02/doc_1111/"/>
    <id>https://github.com/lemon-china/2019/09/02/doc_1111/</id>
    <published>2019-09-02T02:34:12.000Z</published>
    <updated>2019-09-07T13:25:31.189Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/lemon-china/lemon-rabbitmq">lemon-rabbitmq</a></p><p>lemon-rabbitmq   消息生产端</p><p>lemon-rabbitmq-protocol   消息协议层</p><p>lemon-rabbitmq-consumer   消息消费端</p><hr><h4 id="消息协议层"><a href="#消息协议层" class="headerlink" title="消息协议层"></a>消息协议层</h4><p>通过Jackson2序列化/反序列化，实现消息传递和对象接收</p><h4 id="消息生产端"><a href="#消息生产端" class="headerlink" title="消息生产端"></a>消息生产端</h4><p>1、通过发送带有消费端服务类名称和方法请求头，控制消费端调用执行消费发送的信息</p><p>2、利用消息回调接口ConfirmCallback确保消息安全发送至broker服务器，处理效率比事物方式更高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String serviceName, <span class="keyword">final</span> String serviceMethodName,<span class="keyword">final</span> String correlationId, Object request)</span> </span>&#123;</span><br><span class="line">   logger.info(<span class="string">"sendMessage [this.&#123;&#125;, serviceMethodName:&#123;&#125; serviceName:&#123;&#125; correlationId: &#123;&#125;]"</span>, <span class="keyword">this</span>.getClass(), serviceMethodName, serviceName, correlationId);</span><br><span class="line">   rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">   rabbitTemplate.setCorrelationKey(correlationId);</span><br><span class="line">   rabbitTemplate.convertAndSend(routingkey, request, <span class="keyword">new</span> MessagePostProcessor() &#123;            </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">              message.getMessageProperties().setAppId(appId);</span><br><span class="line">              message.getMessageProperties().setTimestamp(<span class="keyword">new</span> Date());</span><br><span class="line">              message.getMessageProperties().setMessageId(UUID.randomUUID().toString());</span><br><span class="line">              message.getMessageProperties().setCorrelationId(correlationId.getBytes());</span><br><span class="line">              message.getMessageProperties().setHeader(<span class="string">"ServiceMethodName"</span>, serviceMethodName);</span><br><span class="line">              message.getMessageProperties().setHeader(<span class="string">"ServiceName"</span>, serviceName);</span><br><span class="line">              <span class="keyword">return</span> message;</span><br><span class="line">          &#125;</span><br><span class="line">   &#125;, <span class="keyword">new</span> CorrelationData(correlationId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息消费端"><a href="#消息消费端" class="headerlink" title="消息消费端"></a>消息消费端</h4><p>1、监听MQ消息，利用method.invoke调用指定的服务类名称和方法，消费接收到的消息</p><p>2、使用Ack/Nack手动确认消息处理状态，保证broker消息被正确消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----- received"</span> + message.getMessageProperties());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object msg = messageConverter.fromMessage(message);</span><br><span class="line"><span class="keyword">if</span> (!appId.equals(message.getMessageProperties().getAppId()))&#123;</span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"非法应用appId:"</span> + message.getMessageProperties().getAppId());</span><br><span class="line">&#125;</span><br><span class="line">Object service = ctx.getBean(message.getMessageProperties().getHeaders().get(<span class="string">"ServiceName"</span>).toString());</span><br><span class="line">String serviceMethodName = message.getMessageProperties().getHeaders().get(<span class="string">"ServiceMethodName"</span>).toString();</span><br><span class="line">Method method = service.getClass().getMethod(serviceMethodName, msg.getClass());</span><br><span class="line">       method.invoke(service, msg);</span><br><span class="line">       <span class="comment">//确认消息成功消费</span></span><br><span class="line">       channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"------ err"</span>+ e.getMessage());</span><br><span class="line">       channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/lemon-china/lemon-rabbitmq&quot;&gt;lemon-rabbitmq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;lemon-rabbitmq   消息生产端&lt;/p&gt;
&lt;p&gt;lemon-rabbitmq-proto
      
    
    </summary>
    
    
      <category term="开源文档" scheme="https://github.com/lemon-china/categories/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="springboot" scheme="https://github.com/lemon-china/tags/springboot/"/>
    
      <category term="java" scheme="https://github.com/lemon-china/tags/java/"/>
    
      <category term="mq" scheme="https://github.com/lemon-china/tags/mq/"/>
    
      <category term="ack/nack" scheme="https://github.com/lemon-china/tags/ack-nack/"/>
    
  </entry>
  
  <entry>
    <title>Hutool工具包类库</title>
    <link href="https://github.com/lemon-china/2019/09/01/tool_1111/"/>
    <id>https://github.com/lemon-china/2019/09/01/tool_1111/</id>
    <published>2019-09-01T12:33:12.000Z</published>
    <updated>2019-09-07T13:07:45.443Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hutool是一个Java工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让Java语言也可以“甜甜的”。Hutool最初是我项目中“util”包的一个整理，后来慢慢积累并加入更多非业务相关功能，并广泛学习其它开源项目精髓，经过自己整理修改，最终形成丰富的开源工具集。</p></blockquote><p>项目地址：<a href="https://hutool.cn" target="_blank" rel="noopener">hutool工具包</a></p><h2 id="日期工具"><a href="#日期工具" class="headerlink" title="日期工具"></a>日期工具</h2><p>通过DateUtil类，提供高度便捷的日期访问、处理和转换方式。</p><h2 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h2><p>通过HttpUtil对HTTP客户端的封装，实现便捷的HTTP请求，并简化文件上传操作。</p><h2 id="转换工具"><a href="#转换工具" class="headerlink" title="转换工具"></a>转换工具</h2><p>通过Convert类中的相应静态方法，提供一整套的类型转换解决方案，并通过ConverterRegistry工厂类自定义转换。</p><h2 id="配置文件工具"><a href="#配置文件工具" class="headerlink" title="配置文件工具"></a>配置文件工具</h2><p>通过Setting对象，提供兼容Properties文件的更加强大的配置文件工具，用于解决中文、分组等JDK配置文件存在的诸多问题。</p><h2 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h2><p>Hutool的日志功能，通过抽象Log接口，提供对Slf4j、LogBack、Log4j、JDK-Logging的全面兼容支持。</p><h2 id="JDBC工具类"><a href="#JDBC工具类" class="headerlink" title="JDBC工具类"></a>JDBC工具类</h2><p>通过db模块，提供对MySQL、Oracle等关系型数据库的JDBC封装，借助ActiveRecord思想，大大简化数据库操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Hutool是一个Java工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让Java语言也可以“甜甜的”。Hutool最初是我项目中“util”包的一个整理，后来慢慢积累并加入更多非业务相关功能，并广泛学习其它开源项目精髓，经过
      
    
    </summary>
    
    
      <category term="常用工具" scheme="https://github.com/lemon-china/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="java" scheme="https://github.com/lemon-china/tags/java/"/>
    
      <category term="开源工具" scheme="https://github.com/lemon-china/tags/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    
      <category term="spring" scheme="https://github.com/lemon-china/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>基于consul注册中心实现cloud微服务框架</title>
    <link href="https://github.com/lemon-china/2019/09/01/exp_1111/"/>
    <id>https://github.com/lemon-china/2019/09/01/exp_1111/</id>
    <published>2019-09-01T02:10:12.000Z</published>
    <updated>2019-09-07T07:38:14.897Z</updated>
    
    <content type="html"><![CDATA[<p>基于consul注册中心实现微服务框架，使用consul替代eureka和git config模式</p><p>本项目预启动时间为2019-03-01，实现以下内容：</p><h4 id="开发计划"><a href="#开发计划" class="headerlink" title="开发计划"></a>开发计划<br></h4><p>v0.1版本 整体服务结构划分，服务边界设定<br><br>v0.2版本 服务网关授权模式搭建<br><br>v0.3版本 前后端技术框架接入<br><br>v0.4版本 服务开发技术规范文档<br><br>v0.5版本 用户基础服务功能<br></p><h4 id="服务架构总览"><a href="#服务架构总览" class="headerlink" title="服务架构总览"></a>服务架构总览<br></h4><p>center  服务综合管理中心 <br><br>&ensp;|—  lemon-gateway  服务网关 <br><br>&ensp;|—  lemon-monitor  服务监控 <br><br>&ensp;|  <br></p><p>commons  服务基础组件中心 <br><br>&ensp;|—  lemon-common  服务通用组件 <br><br>&ensp;|—  lemon-distribution  分布业务锁&amp;任务锁 <br><br>&ensp;|—  lemon-framework  服务基础功能类包 <br><br>&ensp;|—  lemon-rabbit  服务Rabbit功能统一封装组件 <br><br>&ensp;|—  lemon-sharding  数据库分库分表封装组件 <br></p><p>services  微服务中心 <br><br>&ensp;|—  lemon-auth  授权&amp;鉴权服务 <br><br>&ensp;|—  lemon-user  用户服务 <br><br>&ensp;|—  lemon-xxx    <br><br>&ensp;|  <br></p><h4 id="服务项目结构约定"><a href="#服务项目结构约定" class="headerlink" title="服务项目结构约定"></a>服务项目结构约定<br></h4><p>1、服务名由lemon-{xxxx}组成，xxxx为相关微服务的业务名称<br></p><p>2、每个服务脚手架组件包含如下：<br></p><table><thead><tr><th>NO.</th><th>Package</th><th>Desc</th></tr></thead><tbody><tr><td>1</td><td>cn.lemon.{xxxx}.api.rest</td><td>提供对外服务rest接口</td></tr><tr><td>2</td><td>cn.lemon.{xxxx}.api.rpc</td><td>提供对内服务rpc接口</td></tr><tr><td>3</td><td>cn.lemon.{xxxx}.config</td><td>提供服务配置相关</td></tr><tr><td>4</td><td>cn.lemon.{xxxx}.entity.enums</td><td>提供业务枚举类</td></tr><tr><td>5</td><td>cn.lemon.{xxxx}.entity.po</td><td>提供数据库映射实体</td></tr><tr><td>6</td><td>cn.lemon.{xxxx}.entity.vo</td><td>提供对外接口映射实体</td></tr><tr><td>7</td><td>cn.lemon.{xxxx}.rpc.client</td><td>提供对内服务rpc调用接口 (api层不能调用rpc接口)</td></tr><tr><td>8</td><td>cn.lemon.{xxxx}.rpc.client.fallback</td><td>提供对内服务rpc调用失败业务处理</td></tr><tr><td>9</td><td>cn.lemon.{xxxx}.service</td><td>提供业务逻辑接口 (api层调用业务接口)</td></tr><tr><td>10</td><td>cn.lemon.{xxxx}.service.impl</td><td>提供业务逻辑实现</td></tr><tr><td>11</td><td>cn.lemon.{xxxx}.dao</td><td>提供数据库操作</td></tr><tr><td>12</td><td>cn.lemon.{xxxx}.events.pub</td><td>提供MQ发送事件</td></tr><tr><td>13</td><td>cn.lemon.{xxxx}.events.sub</td><td>提供MQ接收事件</td></tr><tr><td>14</td><td>cn.lemon.{xxxx}.task</td><td>提供任务定时执行逻辑</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于consul注册中心实现微服务框架，使用consul替代eureka和git config模式&lt;/p&gt;
&lt;p&gt;本项目预启动时间为2019-03-01，实现以下内容：&lt;/p&gt;
&lt;h4 id=&quot;开发计划&quot;&gt;&lt;a href=&quot;#开发计划&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="经验分享" scheme="https://github.com/lemon-china/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="cloud" scheme="https://github.com/lemon-china/tags/cloud/"/>
    
      <category term="springboot" scheme="https://github.com/lemon-china/tags/springboot/"/>
    
      <category term="consul" scheme="https://github.com/lemon-china/tags/consul/"/>
    
      <category term="java" scheme="https://github.com/lemon-china/tags/java/"/>
    
  </entry>
  
</feed>
