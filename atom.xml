<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wei Echo</title>
  
  <subtitle>高效稳定 · 简洁易用 · 灵活扩展</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/weiecho/"/>
  <updated>2019-09-26T17:34:12.325Z</updated>
  <id>https://github.com/weiecho/</id>
  
  <author>
    <name>Wei Echo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM性能优化建议</title>
    <link href="https://github.com/weiecho/2019/09/20/exp_1113/"/>
    <id>https://github.com/weiecho/2019/09/20/exp_1113/</id>
    <published>2019-09-20T14:30:31.000Z</published>
    <updated>2019-09-26T17:34:12.325Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">优化建议：</span><br><span class="line">1、一般建议Xms等于Xmx，好处是避免每次gc后，调整堆的大小，减少系统内存分配开销</span><br><span class="line">2、串行垃圾收集器(Serial + Serial Old |  -XX:+UseSerialGC)</span><br><span class="line">3、并行垃圾收集器(Parellel + Parellel Old)，吞吐量优先（JVM server 模式 默认）</span><br><span class="line">4、并发垃圾收集器（ParNew + CMS）响应时间优先</span><br><span class="line">5、本次优化说明的JDK版本为1.8</span><br></pre></td></tr></table></figure><h4 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h4><p>1、java -Xmx2g -Xms2g -XX:MetaspaceSize=256m -XX:+UseConcMarkSweepGC</p><h4 id="并发大，对象小"><a href="#并发大，对象小" class="headerlink" title="并发大，对象小"></a>并发大，对象小</h4><p>2、java -Xmx2g -Xms2g -Xmn512m  -XX:MetaspaceSize=256m -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=2  -XX:+UseCMSCompactAtFullCollection</p><h4 id="并发大，对象大"><a href="#并发大，对象大" class="headerlink" title="并发大，对象大"></a>并发大，对象大</h4><p>3、java -Xmx4g -Xms4g -Xmn2g  -XX:MetaspaceSize=512m -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=2  -XX:+UseCMSCompactAtFullCollection</p><table><thead><tr><th>核心参数</th><th>说明</th><th>默认值</th><th>备注</th></tr></thead><tbody><tr><td>-Xms</td><td>最小堆内存</td><td></td><td>默认为物理内存的1/64，不会超过1G</td></tr><tr><td>-Xmx</td><td>最大堆内存</td><td></td><td>默认为物理内存的1/4</td></tr><tr><td>-Xmn</td><td>新生代内存大小</td><td></td><td>默认值为-Xmx的3/8，老年代内存则为5/8 优先级较NewRatio高</td></tr><tr><td>-XX:NewRatio</td><td>新生代与老生代的内存的比值</td><td>2</td><td></td></tr><tr><td>-XX:SurvivorRatio</td><td>Eden和2个存活区内存的比值</td><td>8</td><td></td></tr><tr><td>-XX:MetaspaceSize</td><td>元空间最小值</td><td></td><td>元空间并不在虚拟机中，而是使用本地内存</td></tr><tr><td>-XX:MaxMetaspaceSize</td><td>元空间最大值</td><td></td><td></td></tr><tr><td>-Xss</td><td>栈大小</td><td>1M</td><td></td></tr><tr><td>-XX:ParallelGCThreads</td><td>并行收集器的线程数</td><td>默认为服务器CPU数目</td><td>此值最好配置与处理器数目相等 同样适用于CMS不用设置</td></tr><tr><td>-XX:PretenureSizeThreshold</td><td>手动指定对象大小</td><td></td><td>当对象达到指定大小时直接存放到老年代中，由于新生代大多使用复制算法，为了节省复制消耗</td></tr><tr><td>-XX:MaxTenuringThreshold</td><td>手动设置对象在新生代中存活年龄(存活次数)</td><td>15</td><td></td></tr><tr><td>-XX:+UseConcMarkSweepGC</td><td>手动指定老年代使用CMS收集器</td><td></td><td></td></tr><tr><td>-XX:-CMSParallelRemarkEnabled</td><td>手动配置开启并行标记，节省年轻代标记时间</td><td></td><td>废弃</td></tr><tr><td>-XX:CMSInitiatingOccupancyFraction=80</td><td>手动指定当老年代已用空间达到80%时，触发老年代回收(默认92%)</td><td>-1</td><td></td></tr><tr><td>-XX:+UseCMSCompactAtFullCollection</td><td>在进行Full GC时对内存进行压缩，JDK1.6以前不需要配置，默认开启</td><td></td><td></td></tr><tr><td>-XX:CMSFullGCsBeforeCompaction=2</td><td>与XX:+UseCMSCompactAtFullCollection关联使用标识着每经过多少次Full GC</td><td>0</td><td>触发对内存进行一次压缩，默认是0次</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="经验分享" scheme="https://github.com/weiecho/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="spring" scheme="https://github.com/weiecho/tags/spring/"/>
    
      <category term="架构设计" scheme="https://github.com/weiecho/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="JVM" scheme="https://github.com/weiecho/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>设计实现的健壮性</title>
    <link href="https://github.com/weiecho/2019/09/07/exp_1114/"/>
    <id>https://github.com/weiecho/2019/09/07/exp_1114/</id>
    <published>2019-09-07T14:30:31.000Z</published>
    <updated>2019-09-26T14:04:51.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>日志是发现问题、查看问题一个最常用的手段。日志质量往往被忽视，没有日志使用上的明确约定。重视 Log 的使用，提高 Log 的信息浓度。日志过多、过于混乱，会导致有用的信息被淹没。</p><p>要有效利用这个工具要注意：</p><h4 id="严格约定WARN、ERROR级别记录的内容"><a href="#严格约定WARN、ERROR级别记录的内容" class="headerlink" title="严格约定WARN、ERROR级别记录的内容"></a>严格约定WARN、ERROR级别记录的内容</h4><p>WARN 表示可以恢复的问题，无需人工介入。<br>ERROR 表示需要人工介入问题。<br>有了这样的约定，监管系统发现日志文件的中出现 ERROR 字串就报警，又尽量减少了发生。过多的报警会让人疲倦，使人对报警失去警惕性，使 ERROR 日志失去意义。再辅以人工定期查看 WARN 级别信息，以评估系统的“亚健康”程度。</p><h4 id="日志中，尽量多的收集关键信息"><a href="#日志中，尽量多的收集关键信息" class="headerlink" title="日志中，尽量多的收集关键信息"></a>日志中，尽量多的收集关键信息</h4><p>出问题时的现场信息，即排查问题要用到的信息。如服务调用失败时，要给出使用 Dubbo 的版本、服务提供者的 IP、使用的是哪个注册中心；调用的是哪个服务、哪个方法等等。这些信息如果不给出，那么事后人工收集的，问题过后现场可能已经不能复原，加大排查问题的难度。<br>如果可能，给出问题的原因和解决方法。这让维护和问题解决变得简单，而不是寻求精通者（往往是实现者）的帮助。</p><h4 id="同一个或是一类问题不要重复记录多次"><a href="#同一个或是一类问题不要重复记录多次" class="headerlink" title="同一个或是一类问题不要重复记录多次"></a>同一个或是一类问题不要重复记录多次</h4><p>同一个或是一类异常日志连续出现几十遍的情况，还是常常能看到的。人眼很容易漏掉淹没在其中不一样的重要日志信息。要尽量避免这种情况。在可以预见会出现的情况，有必要加一些逻辑来避免。</p><p>如为一个问题准备一个标志，出问题后打日志后设置标志，避免重复打日志。问题恢复后清除标志。</p><p>虽然有点麻烦，但是这样做保证日志信息浓度，让监控更有效。</p><h2 id="界限设置"><a href="#界限设置" class="headerlink" title="界限设置"></a>界限设置</h2><p>资源是有限的，CPU、内存、IO 等等。不要因为外部的请求、数据不受限的而崩溃。</p><h4 id="线程池-ExectorService-的大小和饱和策略"><a href="#线程池-ExectorService-的大小和饱和策略" class="headerlink" title="线程池(ExectorService)的大小和饱和策略"></a>线程池(ExectorService)的大小和饱和策略</h4><p>Server 端用于处理请求的 ExectorService 设置上限。ExecutorService 的任务等待队列使用有限队列，避免资源耗尽。当任务等待队列饱和时，选择一个合适的饱和策略。这样保证平滑劣化。</p><p>在一些设计中，饱和策略是丢弃数据，等待结果也只是请求的超时。</p><p>达到饱和时，说明已经达到服务提供方的负荷上限，要在饱和策略的操作中日志记录这个问题，以发出监控警报。记得注意不要重复多次记录哦。（注意，缺省的饱和策略不会有这些附加的操作。）根据警报的频率，已经决定扩容调整等等，避免系统问题被忽略。</p><h4 id="集合容量"><a href="#集合容量" class="headerlink" title="集合容量"></a>集合容量</h4><p>如果确保进入集合的元素是可控的且是足够少，则可以放心使用。这是大部分的情况。如果不能保证，则使用有有界的集合。当到达界限时，选择一个合适的丢弃策略。</p><h2 id="容错-重试-恢复"><a href="#容错-重试-恢复" class="headerlink" title="容错-重试-恢复"></a>容错-重试-恢复</h2><p>高可用组件要容忍其依赖组件的失败。</p><h4 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h4><p>目前服务注册中心使用了数据库来保存服务提供者和消费者的信息。注册中心集群不同注册中心也通过数据库来进行同步数据，以感知其它注册中心上提供者的变化。注册中心会在内存中保存一份提供者和消费者数据，数据库不可用时，注册中心独立对外提供服务以保证正常运转，只是拿不到其它注册中心的数据。当数据库恢复时，重试逻辑会将内存中修改的数据写回数据库，并拿到数据库中新数据。</p><h4 id="服务的消费者"><a href="#服务的消费者" class="headerlink" title="服务的消费者"></a>服务的消费者</h4><p>服务消费者从注册中心拿到提供者列表后，会保存提供者列表到内存和磁盘文件中。这样注册中心宕机后消费者可以正常运转，甚至可以在注册中心宕机过程中重启消费者。消费者启动时，发现注册中心不可用，会读取保存在磁盘文件中提供者列表。重试逻辑保证注册中心恢复后，更新信息。</p><h2 id="重试延迟策略"><a href="#重试延迟策略" class="headerlink" title="重试延迟策略"></a>重试延迟策略</h2><h4 id="数据库上的活锁"><a href="#数据库上的活锁" class="headerlink" title="数据库上的活锁"></a>数据库上的活锁</h4><p>注册中心会定时更新数据库一条记录的时间戳，这样集群中其它的注册中心感知它是存活。过期注册中心和它的相关数据 会被清除。数据库正常时，这个机制运行良好。但是数据库负荷高时，其上的每个操作都会很慢。这就出现：</p><p>A 注册中心认为 B 过期，删除 B 的数据。 B 发现自己的数据没有了，重新写入自己的数据的反复操作。这些反复的操作又加重了数据库的负荷，恶化问题。</p><h4 id="可以使用下面逻辑："><a href="#可以使用下面逻辑：" class="headerlink" title="可以使用下面逻辑："></a>可以使用下面逻辑：</h4><p>当 B 发现自己数据被删除时（写入失败），选择等待这段时间再重试。重试时间可以选择指数级增长，如第一次等 1 分钟，第二次 10 分钟、第三次 100 分钟。</p><p>这样操作减少后，保证数据库可以冷却（Cool Down）下来。</p><h4 id="Client-重连注册中心"><a href="#Client-重连注册中心" class="headerlink" title="Client 重连注册中心"></a>Client 重连注册中心</h4><p>当一个注册中心停机时，其它的 Client 会同时接收事件，而去重连另一个注册中心。Client 数量相对比较多，会对注册中心造成冲击。避免方法可以是 Client 重连时随机延时 3 分钟，把重连分散开。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;日志&quot;&gt;&lt;a href=&quot;#日志&quot; class=&quot;headerlink&quot; title=&quot;日志&quot;&gt;&lt;/a&gt;日志&lt;/h2&gt;&lt;p&gt;日志是发现问题、查看问题一个最常用的手段。日志质量往往被忽视，没有日志使用上的明确约定。重视 Log 的使用，提高 Log 的信息浓度。日志
      
    
    </summary>
    
    
      <category term="经验分享" scheme="https://github.com/weiecho/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="spring" scheme="https://github.com/weiecho/tags/spring/"/>
    
      <category term="架构设计" scheme="https://github.com/weiecho/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="微服务" scheme="https://github.com/weiecho/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>乐檬框架之cloud微服务框架</title>
    <link href="https://github.com/weiecho/2019/09/06/doc_1112/"/>
    <id>https://github.com/weiecho/2019/09/06/doc_1112/</id>
    <published>2019-09-06T10:34:12.000Z</published>
    <updated>2019-09-16T06:21:46.496Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于consul注册中心实现微服务框架，使用consul替代eureka和git config模式</p></blockquote><p>项目地址：<a href="https://github.com/weiecho/lemon-consul-cloud">lemon-consul-cloud</a></p><p>本项目预启动时间为2019-03-01，实现以下内容：</p><h4 id="开发计划"><a href="#开发计划" class="headerlink" title="开发计划"></a>开发计划</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v0.1版本 整体服务结构划分，服务边界设定</span><br><span class="line">v0.2版本 服务网关授权模式搭建</span><br><span class="line">v0.3版本 前后端技术框架接入</span><br><span class="line">v0.4版本 服务开发技术规范文档</span><br><span class="line">v0.5版本 用户基础服务功能</span><br></pre></td></tr></table></figure><h4 id="服务框架总览"><a href="#服务框架总览" class="headerlink" title="服务框架总览"></a>服务框架总览</h4><ul><li>lemon-gateway  服务网关</li><li>lemon-monitor  服务监控</li></ul><p>commons  服务基础组件中心</p><ul><li>lemon-common  服务通用组件</li><li>lemon-distribution  分布业务锁&amp;任务锁</li><li>lemon-framework  服务基础功能类包</li><li>lemon-rabbit  服务Rabbit功能统一封装组件</li><li>lemon-sharding  数据库分库分表封装组件</li></ul><p>services  微服务中心</p><ul><li>lemon-auth  授权&amp;鉴权服务</li><li>lemon-user  用户服务</li><li>lemon-xxx   </li></ul><h4 id="服务划分说明"><a href="#服务划分说明" class="headerlink" title="服务划分说明"></a>服务划分说明</h4><p><em>明确划分每个服务的功能</em></p><table><thead><tr><th>NO.</th><th>Module</th><th>Name</th><th>Desc</th></tr></thead><tbody><tr><td>1</td><td>lemon-auth</td><td>授权服务</td><td>用户授权中心管理</td></tr><tr><td>2</td><td>lemon-user</td><td>用户服务</td><td>用户信息中心服务</td></tr><tr><td>3</td><td>lemon-payment</td><td>账务服务</td><td>用户交易中心服务</td></tr><tr><td>4</td><td>lemon-adjust</td><td>核算服务</td><td>账户核算中心服务</td></tr><tr><td>5</td><td>lemon-message</td><td>消息服务</td><td>用户消息中心服务</td></tr></tbody></table><h4 id="服务项目结构约定"><a href="#服务项目结构约定" class="headerlink" title="服务项目结构约定"></a>服务项目结构约定</h4><table><thead><tr><th>NO.</th><th>Package</th><th>Desc</th></tr></thead><tbody><tr><td>1</td><td>cn.lemon.{xxxx}.api.rest</td><td>提供对外服务rest接口</td></tr><tr><td>2</td><td>cn.lemon.{xxxx}.api.rpc</td><td>提供对内服务rpc接口</td></tr><tr><td>3</td><td>cn.lemon.{xxxx}.config</td><td>提供服务配置相关</td></tr><tr><td>4</td><td>cn.lemon.{xxxx}.entity.enums</td><td>提供业务枚举类</td></tr><tr><td>5</td><td>cn.lemon.{xxxx}.entity.po</td><td>提供数据库映射实体</td></tr><tr><td>6</td><td>cn.lemon.{xxxx}.entity.vo</td><td>提供对外接口映射实体</td></tr><tr><td>7</td><td>cn.lemon.{xxxx}.rpc.client</td><td>提供对内服务rpc调用接口 (api层不能调用rpc接口)</td></tr><tr><td>8</td><td>cn.lemon.{xxxx}.rpc.client.fallback</td><td>提供对内服务rpc调用失败业务处理</td></tr><tr><td>9</td><td>cn.lemon.{xxxx}.service</td><td>提供业务逻辑接口 (api层调用业务接口)</td></tr><tr><td>10</td><td>cn.lemon.{xxxx}.service.impl</td><td>提供业务逻辑实现</td></tr><tr><td>11</td><td>cn.lemon.{xxxx}.dao</td><td>提供数据库操作</td></tr><tr><td>12</td><td>cn.lemon.{xxxx}.events.pub</td><td>提供MQ发送事件</td></tr><tr><td>13</td><td>cn.lemon.{xxxx}.events.sub</td><td>提供MQ接收事件</td></tr><tr><td>14</td><td>cn.lemon.{xxxx}.task</td><td>提供任务定时执行逻辑</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于consul注册中心实现微服务框架，使用consul替代eureka和git config模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/weiecho/lemon-consul
      
    
    </summary>
    
    
      <category term="开源文档" scheme="https://github.com/weiecho/categories/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="springboot" scheme="https://github.com/weiecho/tags/springboot/"/>
    
      <category term="cloud" scheme="https://github.com/weiecho/tags/cloud/"/>
    
      <category term="consul" scheme="https://github.com/weiecho/tags/consul/"/>
    
      <category term="lemon" scheme="https://github.com/weiecho/tags/lemon/"/>
    
  </entry>
  
  <entry>
    <title>代码习惯在细节</title>
    <link href="https://github.com/weiecho/2019/09/05/exp_1112/"/>
    <id>https://github.com/weiecho/2019/09/05/exp_1112/</id>
    <published>2019-09-05T07:12:12.000Z</published>
    <updated>2019-09-07T13:51:47.743Z</updated>
    
    <content type="html"><![CDATA[<p>分布式服务框架维护人员增多或变更，会出现质量的下降的问题，尤其是框架代码，要时刻牢记的细节。可能下面要讲的这些，大家都会觉得很简单，很基础，但要做到时刻牢记。在每一行代码中都考虑这些因素，是需要很大耐心的。</p><h3 id="防止空指针和下标越界"><a href="#防止空指针和下标越界" class="headerlink" title="防止空指针和下标越界"></a>防止空指针和下标越界</h3><p>这是我最不喜欢看到的异常，尤其在核心框架中，我更愿看到信息详细的参数不合法异常。这也是一个编写健壮程序的开发人员，在写每一行代码都应在潜意识中防止的异常。基本上要能确保每一次写完的代码，在不测试的情况下，都不会出现这两个异常才算合格。</p><h3 id="保证线程安全性和可见性"><a href="#保证线程安全性和可见性" class="headerlink" title="保证线程安全性和可见性"></a>保证线程安全性和可见性</h3><p>对于框架的开发人员，对线程安全性和可见性的深入理解是最基本的要求。需要开发人员，在写每一行代码时都应在潜意识中确保其正确性。因为这种代码，在小并发下做功能测试时，会显得很正常。但在高并发下就会出现莫明其妙的问题，而且场景很难重现，极难排查。</p><h3 id="尽早失败和前置断言"><a href="#尽早失败和前置断言" class="headerlink" title="尽早失败和前置断言"></a>尽早失败和前置断言</h3><p>尽早失败也应该成为潜意识，在有传入参数和状态变化时，均在入口处全部断言。一个不合法的值和状态，在第一时间就应报错，而不是等到要用时才报错。因为等到要用时，可能前面已经修改其它相关状态，而在程序中很少有人去处理回滚逻辑。这样报错后，其实内部状态可能已经混乱，极易在一个隐蔽分支上引发程序不可恢复。</p><h3 id="分离可靠操作和不可靠操作"><a href="#分离可靠操作和不可靠操作" class="headerlink" title="分离可靠操作和不可靠操作"></a>分离可靠操作和不可靠操作</h3><p>这里的可靠是狭义的指是否会抛出异常或引起状态不一致，比如，写入一个线程安全的 Map，可以认为是可靠的，而写入数据库等，可以认为是不可靠的。开发人员必须在写每一行代码时，都注意它的可靠性与否，在代码中尽量划分开，并对失败做异常处理，并为容错，自我保护，自动恢复或切换等补偿逻辑提供清晰的切入点，保证后续增加的代码不至于放错位置，而导致原先的容错处理陷入混乱。</p><h3 id="异常防御，但不忽略异常"><a href="#异常防御，但不忽略异常" class="headerlink" title="异常防御，但不忽略异常"></a>异常防御，但不忽略异常</h3><p>这里讲的异常防御，指的是对非必须途径上的代码进行最大限度的容忍，包括程序上的 BUG，比如：获取程序的版本号，会通过扫描 Manifest 和 jar 包名称抓取版本号，这个逻辑是辅助性的，但代码却不少，初步测试也没啥问题，但应该在整个 getVersion() 中加上一个全函数的 try-catch 打印错误日志，并返回基本版本，因为 getVersion() 可能存在未知特定场景异常，或被其他的开发人员误修改逻辑(但一般人员不会去掉 try-catch)，而如果它抛出异常会导致主流程异常，这是我们不希望看到的。但这里要控制个度，不要随意 try-catch，更不要无声无息的吃掉异常。</p><h3 id="缩小可变域和尽量-final"><a href="#缩小可变域和尽量-final" class="headerlink" title="缩小可变域和尽量 final"></a>缩小可变域和尽量 final</h3><p>如果一个类可以成为不变类(Immutable Class)，就优先将它设计成不变类。不变类有天然的并发共享优势，减少同步或复制，而且可以有效帮忙分析线程安全的范围。就算是可变类，对于从构造函数传入的引用，在类中持有时，最好将字段 final，以免被中途误修改引用。不要以为这个字段是私有的，这个类的代码都是我自己写的，不会出现对这个字段的重新赋值。要考虑的一个因素是，这个代码可能被其他人修改，他不知道你的这个弱约定，final 就是一个不变契约。</p><h3 id="降低修改时的误解性，不埋雷"><a href="#降低修改时的误解性，不埋雷" class="headerlink" title="降低修改时的误解性，不埋雷"></a>降低修改时的误解性，不埋雷</h3><p>前面不停的提到代码被其他人修改，这也开发人员要随时紧记的。这个其他人包括未来的自己，你要总想着这个代码可能会有人去改它。我应该给修改的人一点什么提示，让他知道我现在的设计意图，而不要在程序里面加潜规则，或埋一些容易忽视的雷，比如：你用 null 表示不可用，size 等于 0 表示黑名单，这就是一个雷，下一个修改者，包括你自己，都不会记得有这样的约定，可能后面为了改某个其它 BUG，不小心改到了这里，直接引爆故障。对于这个例子，一个原则就是永远不要区分 null 引用和 empty 值。</p><h3 id="提高代码的可测性"><a href="#提高代码的可测性" class="headerlink" title="提高代码的可测性"></a>提高代码的可测性</h3><p>这里的可测性主要指 Mock 的容易程度，和测试的隔离性。至于测试的自动性，可重复性，非偶然性，无序性，完备性(全覆盖)，轻量性(可快速执行)，一般开发人员，加上 JUnit 等工具的辅助基本都能做到，也能理解它的好处，只是工作量问题。这里要特别强调的是测试用例的单一性(只测目标类本身)和隔离性(不传染失败)。现在的测试代码，过于强调完备性，大量重复交叉测试，看起来没啥坏处，但测试代码越多，维护代价越高。经常出现的问题是，修改一行代码或加一个判断条件，引起 100 多个测试用例不通过。时间一紧，谁有这个闲功夫去改这么多形态各异的测试用例？久而久之，这个测试代码就已经不能真实反应代码现在的状况，很多时候会被迫绕过。最好的情况是，修改一行代码，有且只有一行测试代码不通过。如果修改了代码而测试用例还能通过，那也不行，表示测试没有覆盖到。另外，可 Mock 性是隔离的基础，把间接依赖的逻辑屏蔽掉。可 Mock 性的一个最大的杀手就是静态方法，尽量少用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分布式服务框架维护人员增多或变更，会出现质量的下降的问题，尤其是框架代码，要时刻牢记的细节。可能下面要讲的这些，大家都会觉得很简单，很基础，但要做到时刻牢记。在每一行代码中都考虑这些因素，是需要很大耐心的。&lt;/p&gt;
&lt;h3 id=&quot;防止空指针和下标越界&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="经验分享" scheme="https://github.com/weiecho/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="springboot" scheme="https://github.com/weiecho/tags/springboot/"/>
    
      <category term="cloud" scheme="https://github.com/weiecho/tags/cloud/"/>
    
      <category term="分布式" scheme="https://github.com/weiecho/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>XXL-JOB分布式任务快速入门</title>
    <link href="https://github.com/weiecho/2019/09/04/stu_1111/"/>
    <id>https://github.com/weiecho/2019/09/04/stu_1111/</id>
    <published>2019-09-04T07:21:11.000Z</published>
    <updated>2019-09-07T13:07:34.938Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。</p></blockquote><p>项目地址：<a href="http://www.xuxueli.com/xxl-job/" target="_blank" rel="noopener">xxl-job分布式任务调度平台</a></p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><ul><li>调度中心 xxl-job-admin</li><li>公共依赖 xxl-job-core</li><li>任务执行器 opay-xxx</li></ul><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><ul><li>调度中心集群</li><li>DB配置保持一致</li><li>登陆账号配置保持一致</li><li>集群机器时钟保持一致<br><em>建议：推荐通过nginx为调度中心集群做负载均衡，分配域名</em></li><li>调度中心访问、执行器回调配置、调用API服务等操作均通过该域名进行。</li><li>执行器集群<ul><li>执行器回调地址保持一致<br><em>xxl.job.admin.addresses</em></li><li>执行器集群内AppName保持一致<br><em>xxl.job.executor.appname​</em></li></ul></li></ul><h3 id="任务关键点"><a href="#任务关键点" class="headerlink" title="任务关键点"></a>任务关键点</h3><ul><li>执行器</li><li>任务描述</li><li>路由策略<ul><li>FIRST（第一个）<br><em>固定选择第一个机器</em></li><li>LAST（最后一个）<br><em>固定选择最后一个机器</em></li><li>ROUND（轮询）</li><li>RANDOM（随机）<br><em>随机选择在线的机器</em></li><li>CONSISTENT_HASH（一致性HASH）<br><em>每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上</em></li><li>LEAST_FREQUENTLY_USED（最不经常使用）<br><em>使用频率最低的机器优先被选举</em></li><li>LEAST_RECENTLY_USED（最近最久未使用）<br><em>最久为使用的机器优先被选举</em></li><li>FAILOVER（故障转移）<br><em>按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度</em></li><li>BUSYOVER（忙碌转移）<br><em>按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度</em></li><li>SHARDING_BROADCAST(分片广播)<br><em>广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数，可根据分片参数开发分片任务</em> </li></ul></li><li>Cron表达式<ul><li>运行模式<ul><li>BEAN</li><li>GLUE</li><li>JobHandler<br><em>任务bean名称@JobHandler</em></li></ul></li></ul></li><li>阻塞策略<ul><li>单机串行<br><em>进入单机执行器后，进入FIFO队列并以串行方式运行</em></li><li>丢弃后续调度<br><em>进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败</em></li><li>覆盖之前调度<br><em>进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列</em></li></ul></li><li>负责人</li><li>其他<ul><li>子任务ID</li><li>超时时间</li><li>重试次数</li><li>报警邮件</li><li>任务参数</li></ul></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>日志文件目录需要权限<br><em>默认 /data/applogs/xxl-job/jobhandler​</em></li><li>设置日志保存天数<br><em>xxl.job.executor.logretentiondays=-1 //大于3生效</em></li><li>执行日志需要通过 “XxlJobLogger.log” 打印执行日志</li><li>admin执行任务时报错 Communications link failure<br><em>数据库链接地址加上 &amp;autoReconnect=true&amp;failOverReadOnly=false</em></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;http://www.xux
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://github.com/weiecho/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="https://github.com/weiecho/tags/java/"/>
    
      <category term="开源工具" scheme="https://github.com/weiecho/tags/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    
      <category term="定时任务" scheme="https://github.com/weiecho/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>XXL-JOB分布式任务调度平台</title>
    <link href="https://github.com/weiecho/2019/09/03/tool_1112/"/>
    <id>https://github.com/weiecho/2019/09/03/tool_1112/</id>
    <published>2019-09-03T05:23:12.000Z</published>
    <updated>2019-09-07T13:07:38.251Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。</p></blockquote><p>项目地址：<a href="http://www.xuxueli.com/xxl-job/" target="_blank" rel="noopener">xxl-job分布式任务调度平台</a></p><ul><li>简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手；</li><li>动态：支持动态修改任务状态、启动/停止任务，以及终止运行中任务，即时生效；</li><li>调度中心HA（中心式）：调度采用中心式设计，“调度中心”自研调度组件并支持集群部署，可保证调度中心HA；</li><li>执行器HA（分布式）：任务分布式执行，任务”执行器”支持集群部署，可保证任务执行HA；</li><li>注册中心: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址；</li><li>弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务；</li><li>路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等；</li><li>故障转移：任务路由策略选择”故障转移”情况下，如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求。</li><li>阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度；</li><li>任务超时控制：支持自定义任务超时时间，任务运行超时将会主动中断任务；</li><li>任务失败重试：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；其中分片任务支持分片粒度的失败重试；</li><li>任务失败告警；默认提供邮件方式失败告警，同时预留扩展接口，可方便的扩展短信、钉钉等告警方式；</li><li>分片广播任务：执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务；</li><li>动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。</li><li>事件触发：除了”Cron方式”和”任务依赖方式”触发任务执行之外，支持基于事件的触发任务方式。调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发。</li><li>任务进度监控：支持实时监控任务进度；</li><li>Rolling实时日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志；</li><li>GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。</li><li>脚本任务：支持以GLUE模式开发和运行脚本任务，包括Shell、Python、NodeJS、PHP、PowerShell等类型脚本;</li><li>命令行任务：原生提供通用命令行任务Handler（Bean任务，”CommandJobHandler”）；业务方只需要提供命令行即可；</li><li>任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行, 多个子任务用逗号分隔；</li><li>一致性：“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；</li><li>自定义任务参数：支持在线配置调度任务入参，即时生效；</li><li>调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞；</li><li>数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性；</li><li>邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件；</li><li>推送maven中央仓库: 将会把最新稳定版推送到maven中央仓库, 方便用户接入和使用;</li><li>运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等；</li><li>全异步：任务调度流程全异步化设计实现，如异步调度、异步运行、异步回调等，有效对密集调度进行流量削峰，理论上支持任意时长任务的运行；</li><li>跨平台：原生提供通用HTTP任务Handler（Bean任务，”HttpJobHandler”）；业务方只需要提供HTTP链接即可，不限制语言、平台；</li><li>国际化：调度中心支持国际化设置，提供中文、英文两种可选语言，默认为中文；</li><li>容器化：提供官方docker镜像，并实时更新推送dockerhub，进一步实现产品开箱即用；</li><li>线程池隔离：调度线程池进行隔离拆分，慢任务自动降级进入”Slow”线程池，避免耗尽调度线程，提高系统稳定性；</li><li>用户管理：支持在线管理系统用户，存在管理员、普通用户两种角色；</li><li>权限控制：执行器维度进行权限控制，管理员拥有全量权限，普通用户需要分配执行器权限后才允许相关操作。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;http://www.xux
      
    
    </summary>
    
    
      <category term="常用工具" scheme="https://github.com/weiecho/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="java" scheme="https://github.com/weiecho/tags/java/"/>
    
      <category term="开源工具" scheme="https://github.com/weiecho/tags/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    
      <category term="定时任务" scheme="https://github.com/weiecho/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>服务开发核心思想</title>
    <link href="https://github.com/weiecho/2019/09/03/exp_1111/"/>
    <id>https://github.com/weiecho/2019/09/03/exp_1111/</id>
    <published>2019-09-03T04:30:12.000Z</published>
    <updated>2019-09-07T13:51:42.936Z</updated>
    
    <content type="html"><![CDATA[<h3 id="保障服务可扩展性的七大原则"><a href="#保障服务可扩展性的七大原则" class="headerlink" title="保障服务可扩展性的七大原则"></a>保障服务可扩展性的七大原则</h3><p>1、按功能划分</p><p>2、水平切分</p><p>3、尽量避免事务</p><p>4、适当采用异步解耦</p><p>5、次流程改进为异步</p><p>6、虚拟化所有层次</p><p>7、适当使用缓存</p><h3 id="服务拆分开发的四项原则"><a href="#服务拆分开发的四项原则" class="headerlink" title="服务拆分开发的四项原则"></a>服务拆分开发的四项原则</h3><p>1、先业务后技术，先逻辑后物理</p><p>2、奥卡姆剃刀：如无必须勿增实体</p><p>3、正交性：抽象出模块间无业务相关的重复代码</p><p>4、稳定性原则：服务的稳定性优先，通过拆分解耦</p><blockquote><p>可参考的技术方案：接口化、消息队列、模块化、服务化、异步化</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;保障服务可扩展性的七大原则&quot;&gt;&lt;a href=&quot;#保障服务可扩展性的七大原则&quot; class=&quot;headerlink&quot; title=&quot;保障服务可扩展性的七大原则&quot;&gt;&lt;/a&gt;保障服务可扩展性的七大原则&lt;/h3&gt;&lt;p&gt;1、按功能划分&lt;/p&gt;
&lt;p&gt;2、水平切分&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="经验分享" scheme="https://github.com/weiecho/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="springboot" scheme="https://github.com/weiecho/tags/springboot/"/>
    
      <category term="cloud" scheme="https://github.com/weiecho/tags/cloud/"/>
    
      <category term="分布式" scheme="https://github.com/weiecho/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Apollo分布式配置中心快速入门</title>
    <link href="https://github.com/weiecho/2019/09/02/stu_1112/"/>
    <id>https://github.com/weiecho/2019/09/02/stu_1112/</id>
    <published>2019-09-02T04:21:22.000Z</published>
    <updated>2019-09-07T13:31:36.409Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</p></blockquote><p>项目地址：<a href="https://github.com/ctripcorp/apollo">apollo分布式配置中心</a></p><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><ul><li>AppId</li><li>ENV</li><li>Cluster</li><li>Namespace<ul><li>Public</li><li>Private</li><li>关联(继承)</li></ul></li></ul><h2 id="操作点"><a href="#操作点" class="headerlink" title="操作点"></a>操作点</h2><ul><li>发布</li><li>回滚</li><li>灰度</li><li>创建Cluster</li><li>创建/关联Namespace</li></ul><h2 id="核心点"><a href="#核心点" class="headerlink" title="核心点"></a>核心点</h2><ul><li>项目AppId</li><li>宿主机ENV</li><li>apollo.meta</li><li>Private <em>AppId</em></li><li>Public <em>Share</em></li><li>可多Namespace</li><li>Public关联 / 覆盖</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目地址
      
    
    </summary>
    
    
      <category term="学习笔记" scheme="https://github.com/weiecho/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="https://github.com/weiecho/tags/java/"/>
    
      <category term="开源工具" scheme="https://github.com/weiecho/tags/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    
      <category term="定时任务" scheme="https://github.com/weiecho/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
    
      <category term="apollo" scheme="https://github.com/weiecho/tags/apollo/"/>
    
  </entry>
  
  <entry>
    <title>乐檬框架之rabbitMQ的解耦实现方式</title>
    <link href="https://github.com/weiecho/2019/09/02/doc_1111/"/>
    <id>https://github.com/weiecho/2019/09/02/doc_1111/</id>
    <published>2019-09-02T02:34:12.000Z</published>
    <updated>2019-09-16T06:21:46.494Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/weiecho/lemon-rabbitmq">lemon-rabbitmq</a></p><p>lemon-rabbitmq   消息生产端</p><p>lemon-rabbitmq-protocol   消息协议层</p><p>lemon-rabbitmq-consumer   消息消费端</p><hr><h4 id="消息协议层"><a href="#消息协议层" class="headerlink" title="消息协议层"></a>消息协议层</h4><p>通过Jackson2序列化/反序列化，实现消息传递和对象接收</p><h4 id="消息生产端"><a href="#消息生产端" class="headerlink" title="消息生产端"></a>消息生产端</h4><p>1、通过发送带有消费端服务类名称和方法请求头，控制消费端调用执行消费发送的信息</p><p>2、利用消息回调接口ConfirmCallback确保消息安全发送至broker服务器，处理效率比事物方式更高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String serviceName, <span class="keyword">final</span> String serviceMethodName,<span class="keyword">final</span> String correlationId, Object request)</span> </span>&#123;</span><br><span class="line">   logger.info(<span class="string">"sendMessage [this.&#123;&#125;, serviceMethodName:&#123;&#125; serviceName:&#123;&#125; correlationId: &#123;&#125;]"</span>, <span class="keyword">this</span>.getClass(), serviceMethodName, serviceName, correlationId);</span><br><span class="line">   rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">   rabbitTemplate.setCorrelationKey(correlationId);</span><br><span class="line">   rabbitTemplate.convertAndSend(routingkey, request, <span class="keyword">new</span> MessagePostProcessor() &#123;            </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">              message.getMessageProperties().setAppId(appId);</span><br><span class="line">              message.getMessageProperties().setTimestamp(<span class="keyword">new</span> Date());</span><br><span class="line">              message.getMessageProperties().setMessageId(UUID.randomUUID().toString());</span><br><span class="line">              message.getMessageProperties().setCorrelationId(correlationId.getBytes());</span><br><span class="line">              message.getMessageProperties().setHeader(<span class="string">"ServiceMethodName"</span>, serviceMethodName);</span><br><span class="line">              message.getMessageProperties().setHeader(<span class="string">"ServiceName"</span>, serviceName);</span><br><span class="line">              <span class="keyword">return</span> message;</span><br><span class="line">          &#125;</span><br><span class="line">   &#125;, <span class="keyword">new</span> CorrelationData(correlationId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息消费端"><a href="#消息消费端" class="headerlink" title="消息消费端"></a>消息消费端</h4><p>1、监听MQ消息，利用method.invoke调用指定的服务类名称和方法，消费接收到的消息</p><p>2、使用Ack/Nack手动确认消息处理状态，保证broker消息被正确消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----- received"</span> + message.getMessageProperties());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object msg = messageConverter.fromMessage(message);</span><br><span class="line"><span class="keyword">if</span> (!appId.equals(message.getMessageProperties().getAppId()))&#123;</span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"非法应用appId:"</span> + message.getMessageProperties().getAppId());</span><br><span class="line">&#125;</span><br><span class="line">Object service = ctx.getBean(message.getMessageProperties().getHeaders().get(<span class="string">"ServiceName"</span>).toString());</span><br><span class="line">String serviceMethodName = message.getMessageProperties().getHeaders().get(<span class="string">"ServiceMethodName"</span>).toString();</span><br><span class="line">Method method = service.getClass().getMethod(serviceMethodName, msg.getClass());</span><br><span class="line">       method.invoke(service, msg);</span><br><span class="line">       <span class="comment">//确认消息成功消费</span></span><br><span class="line">       channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"------ err"</span>+ e.getMessage());</span><br><span class="line">       channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/weiecho/lemon-rabbitmq&quot;&gt;lemon-rabbitmq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;lemon-rabbitmq   消息生产端&lt;/p&gt;
&lt;p&gt;lemon-rabbitmq-protocol 
      
    
    </summary>
    
    
      <category term="开源文档" scheme="https://github.com/weiecho/categories/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="mq" scheme="https://github.com/weiecho/tags/mq/"/>
    
      <category term="springboot" scheme="https://github.com/weiecho/tags/springboot/"/>
    
      <category term="ack/nack" scheme="https://github.com/weiecho/tags/ack-nack/"/>
    
      <category term="java" scheme="https://github.com/weiecho/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Hutool工具包类库</title>
    <link href="https://github.com/weiecho/2019/09/01/tool_1111/"/>
    <id>https://github.com/weiecho/2019/09/01/tool_1111/</id>
    <published>2019-09-01T12:33:12.000Z</published>
    <updated>2019-09-07T13:07:45.443Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Hutool是一个Java工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让Java语言也可以“甜甜的”。Hutool最初是我项目中“util”包的一个整理，后来慢慢积累并加入更多非业务相关功能，并广泛学习其它开源项目精髓，经过自己整理修改，最终形成丰富的开源工具集。</p></blockquote><p>项目地址：<a href="https://hutool.cn" target="_blank" rel="noopener">hutool工具包</a></p><h2 id="日期工具"><a href="#日期工具" class="headerlink" title="日期工具"></a>日期工具</h2><p>通过DateUtil类，提供高度便捷的日期访问、处理和转换方式。</p><h2 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h2><p>通过HttpUtil对HTTP客户端的封装，实现便捷的HTTP请求，并简化文件上传操作。</p><h2 id="转换工具"><a href="#转换工具" class="headerlink" title="转换工具"></a>转换工具</h2><p>通过Convert类中的相应静态方法，提供一整套的类型转换解决方案，并通过ConverterRegistry工厂类自定义转换。</p><h2 id="配置文件工具"><a href="#配置文件工具" class="headerlink" title="配置文件工具"></a>配置文件工具</h2><p>通过Setting对象，提供兼容Properties文件的更加强大的配置文件工具，用于解决中文、分组等JDK配置文件存在的诸多问题。</p><h2 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h2><p>Hutool的日志功能，通过抽象Log接口，提供对Slf4j、LogBack、Log4j、JDK-Logging的全面兼容支持。</p><h2 id="JDBC工具类"><a href="#JDBC工具类" class="headerlink" title="JDBC工具类"></a>JDBC工具类</h2><p>通过db模块，提供对MySQL、Oracle等关系型数据库的JDBC封装，借助ActiveRecord思想，大大简化数据库操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Hutool是一个Java工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让Java语言也可以“甜甜的”。Hutool最初是我项目中“util”包的一个整理，后来慢慢积累并加入更多非业务相关功能，并广泛学习其它开源项目精髓，经过
      
    
    </summary>
    
    
      <category term="常用工具" scheme="https://github.com/weiecho/categories/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="java" scheme="https://github.com/weiecho/tags/java/"/>
    
      <category term="spring" scheme="https://github.com/weiecho/tags/spring/"/>
    
      <category term="开源工具" scheme="https://github.com/weiecho/tags/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>开发者约定</title>
    <link href="https://github.com/weiecho/2019/09/01/doc_1110/"/>
    <id>https://github.com/weiecho/2019/09/01/doc_1110/</id>
    <published>2019-09-01T02:10:12.000Z</published>
    <updated>2019-09-11T01:54:23.719Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文档约定了服务开发人员的代码规范，从而增强代码的一致性和可维护性</p></blockquote><p>1、接口地址和参数严格区分大小写，接口尽量全部小写，参数使用驼峰命名；</p><p>2、接口默认以请求参数形式传入参数，响应返回JSON格式数据；</p><p>3、H5内所有资源引用打包自动带上日期版本号，防止发布版本引用资源在浏览器缓存导致功能异常（如：./jquery-1.11.0.js?v=201806051011）</p><p>4、接口请求数据均需要携带header参数：</p><table><thead><tr><th align="left">参数名</th><th align="left">必填</th><th align="left">类型</th><th>说明</th></tr></thead><tbody><tr><td align="left">x-auth-token</td><td align="left">是</td><td align="left">string</td><td>登录后返回的token</td></tr><tr><td align="left">x-app-version</td><td align="left">是</td><td align="left">string</td><td>应用版本（固定 1.0.0）</td></tr><tr><td align="left">x-device</td><td align="left">是</td><td align="left">integer</td><td>设备类型(1：IOS 2：Android 3：wap 4: 微信 5: H5)</td></tr><tr><td align="left">x-device-name</td><td align="left">是</td><td align="left">string</td><td>设备/浏览器名称（如：huawei/Chrome）</td></tr><tr><td align="left">x-timestamp</td><td align="left">是</td><td align="left">long</td><td>10位时间戳</td></tr></tbody></table><p>5、接口返回数据JSON格式标准: </p><table><thead><tr><th align="left">参数名</th><th align="left">类型</th><th>说明</th></tr></thead><tbody><tr><td align="left">code</td><td align="left">integer</td><td>状态码</td></tr><tr><td align="left">message</td><td align="left">string</td><td>状态/错误信息</td></tr><tr><td align="left">data</td><td align="left">object</td><td>返回的数据</td></tr></tbody></table><p>不带返回数据示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"操作成功"</span>,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"2000"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带返回数据示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"操作成功"</span>,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"2000"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"userId"</span>: <span class="string">"1488512189"</span>,</span><br><span class="line">        <span class="attr">"nickName"</span>: <span class="string">"哈哈"</span>,</span><br><span class="line">        <span class="attr">"vip"</span>: <span class="string">"12"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常返回示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"短信验证码发送失败"</span>,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"6017"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文档约定了服务开发人员的代码规范，从而增强代码的一致性和可维护性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、接口地址和参数严格区分大小写，接口尽量全部小写，参数使用驼峰命名；&lt;/p&gt;
&lt;p&gt;2、接口默认以请求参数形式传入参数，响应返回JSON
      
    
    </summary>
    
    
      <category term="开源文档" scheme="https://github.com/weiecho/categories/%E5%BC%80%E6%BA%90%E6%96%87%E6%A1%A3/"/>
    
    
      <category term="java" scheme="https://github.com/weiecho/tags/java/"/>
    
      <category term="微服务" scheme="https://github.com/weiecho/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="开发规范" scheme="https://github.com/weiecho/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
</feed>
