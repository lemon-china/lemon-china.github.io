<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lemon-china</title>
  
  <subtitle>乐檬·中国致力于打造最优雅的系统框架</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/lemon-china/"/>
  <updated>2019-09-07T05:48:40.352Z</updated>
  <id>https://github.com/lemon-china/</id>
  
  <author>
    <name>lemon-china</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>服务开发核心思想</title>
    <link href="https://github.com/lemon-china/2019/09/05/cloud-mind/"/>
    <id>https://github.com/lemon-china/2019/09/05/cloud-mind/</id>
    <published>2019-09-05T04:30:12.000Z</published>
    <updated>2019-09-07T05:48:40.352Z</updated>
    
    <content type="html"><![CDATA[<h3 id="保障服务可扩展性的七大原则"><a href="#保障服务可扩展性的七大原则" class="headerlink" title="保障服务可扩展性的七大原则"></a>保障服务可扩展性的七大原则</h3><p>1、按功能划分</p><p>2、水平切分</p><p>3、尽量避免事务</p><p>4、适当采用异步解耦</p><p>5、次流程改进为异步</p><p>6、虚拟化所有层次</p><p>7、适当使用缓存</p><h3 id="服务拆分开发的四项原则"><a href="#服务拆分开发的四项原则" class="headerlink" title="服务拆分开发的四项原则"></a>服务拆分开发的四项原则</h3><p>1、先业务后技术，先逻辑后物理</p><p>2、奥卡姆剃刀：如无必须勿增实体</p><p>3、正交性：抽象出模块间无业务相关的重复代码</p><p>4、稳定性原则：服务的稳定性优先，通过拆分解耦</p><h4 id="PS-可参考的技术方案：接口化、消息队列、模块化、服务化、异步化"><a href="#PS-可参考的技术方案：接口化、消息队列、模块化、服务化、异步化" class="headerlink" title="PS: 可参考的技术方案：接口化、消息队列、模块化、服务化、异步化"></a>PS: 可参考的技术方案：接口化、消息队列、模块化、服务化、异步化</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;保障服务可扩展性的七大原则&quot;&gt;&lt;a href=&quot;#保障服务可扩展性的七大原则&quot; class=&quot;headerlink&quot; title=&quot;保障服务可扩展性的七大原则&quot;&gt;&lt;/a&gt;保障服务可扩展性的七大原则&lt;/h3&gt;&lt;p&gt;1、按功能划分&lt;/p&gt;
&lt;p&gt;2、水平切分&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="技术规范" scheme="https://github.com/lemon-china/categories/%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="springboot" scheme="https://github.com/lemon-china/tags/springboot/"/>
    
      <category term="cloud" scheme="https://github.com/lemon-china/tags/cloud/"/>
    
      <category term="分布式" scheme="https://github.com/lemon-china/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代码习惯在细节</title>
    <link href="https://github.com/lemon-china/2019/09/02/cloud-rule/"/>
    <id>https://github.com/lemon-china/2019/09/02/cloud-rule/</id>
    <published>2019-09-02T07:12:12.000Z</published>
    <updated>2019-09-07T05:34:44.696Z</updated>
    
    <content type="html"><![CDATA[<p>分布式服务框架维护人员增多或变更，会出现质量的下降的问题，尤其是框架代码，要时刻牢记的细节。可能下面要讲的这些，大家都会觉得很简单，很基础，但要做到时刻牢记。在每一行代码中都考虑这些因素，是需要很大耐心的。</p><h3 id="防止空指针和下标越界"><a href="#防止空指针和下标越界" class="headerlink" title="防止空指针和下标越界"></a>防止空指针和下标越界</h3><p>这是我最不喜欢看到的异常，尤其在核心框架中，我更愿看到信息详细的参数不合法异常。这也是一个编写健壮程序的开发人员，在写每一行代码都应在潜意识中防止的异常。基本上要能确保每一次写完的代码，在不测试的情况下，都不会出现这两个异常才算合格。</p><h3 id="保证线程安全性和可见性"><a href="#保证线程安全性和可见性" class="headerlink" title="保证线程安全性和可见性"></a>保证线程安全性和可见性</h3><p>对于框架的开发人员，对线程安全性和可见性的深入理解是最基本的要求。需要开发人员，在写每一行代码时都应在潜意识中确保其正确性。因为这种代码，在小并发下做功能测试时，会显得很正常。但在高并发下就会出现莫明其妙的问题，而且场景很难重现，极难排查。</p><h3 id="尽早失败和前置断言"><a href="#尽早失败和前置断言" class="headerlink" title="尽早失败和前置断言"></a>尽早失败和前置断言</h3><p>尽早失败也应该成为潜意识，在有传入参数和状态变化时，均在入口处全部断言。一个不合法的值和状态，在第一时间就应报错，而不是等到要用时才报错。因为等到要用时，可能前面已经修改其它相关状态，而在程序中很少有人去处理回滚逻辑。这样报错后，其实内部状态可能已经混乱，极易在一个隐蔽分支上引发程序不可恢复。</p><h3 id="分离可靠操作和不可靠操作"><a href="#分离可靠操作和不可靠操作" class="headerlink" title="分离可靠操作和不可靠操作"></a>分离可靠操作和不可靠操作</h3><p>这里的可靠是狭义的指是否会抛出异常或引起状态不一致，比如，写入一个线程安全的 Map，可以认为是可靠的，而写入数据库等，可以认为是不可靠的。开发人员必须在写每一行代码时，都注意它的可靠性与否，在代码中尽量划分开，并对失败做异常处理，并为容错，自我保护，自动恢复或切换等补偿逻辑提供清晰的切入点，保证后续增加的代码不至于放错位置，而导致原先的容错处理陷入混乱。</p><h3 id="异常防御，但不忽略异常"><a href="#异常防御，但不忽略异常" class="headerlink" title="异常防御，但不忽略异常"></a>异常防御，但不忽略异常</h3><p>这里讲的异常防御，指的是对非必须途径上的代码进行最大限度的容忍，包括程序上的 BUG，比如：获取程序的版本号，会通过扫描 Manifest 和 jar 包名称抓取版本号，这个逻辑是辅助性的，但代码却不少，初步测试也没啥问题，但应该在整个 getVersion() 中加上一个全函数的 try-catch 打印错误日志，并返回基本版本，因为 getVersion() 可能存在未知特定场景异常，或被其他的开发人员误修改逻辑(但一般人员不会去掉 try-catch)，而如果它抛出异常会导致主流程异常，这是我们不希望看到的。但这里要控制个度，不要随意 try-catch，更不要无声无息的吃掉异常。</p><h3 id="缩小可变域和尽量-final"><a href="#缩小可变域和尽量-final" class="headerlink" title="缩小可变域和尽量 final"></a>缩小可变域和尽量 final</h3><p>如果一个类可以成为不变类(Immutable Class)，就优先将它设计成不变类。不变类有天然的并发共享优势，减少同步或复制，而且可以有效帮忙分析线程安全的范围。就算是可变类，对于从构造函数传入的引用，在类中持有时，最好将字段 final，以免被中途误修改引用。不要以为这个字段是私有的，这个类的代码都是我自己写的，不会出现对这个字段的重新赋值。要考虑的一个因素是，这个代码可能被其他人修改，他不知道你的这个弱约定，final 就是一个不变契约。</p><h3 id="降低修改时的误解性，不埋雷"><a href="#降低修改时的误解性，不埋雷" class="headerlink" title="降低修改时的误解性，不埋雷"></a>降低修改时的误解性，不埋雷</h3><p>前面不停的提到代码被其他人修改，这也开发人员要随时紧记的。这个其他人包括未来的自己，你要总想着这个代码可能会有人去改它。我应该给修改的人一点什么提示，让他知道我现在的设计意图，而不要在程序里面加潜规则，或埋一些容易忽视的雷，比如：你用 null 表示不可用，size 等于 0 表示黑名单，这就是一个雷，下一个修改者，包括你自己，都不会记得有这样的约定，可能后面为了改某个其它 BUG，不小心改到了这里，直接引爆故障。对于这个例子，一个原则就是永远不要区分 null 引用和 empty 值。</p><h3 id="提高代码的可测性"><a href="#提高代码的可测性" class="headerlink" title="提高代码的可测性"></a>提高代码的可测性</h3><p>这里的可测性主要指 Mock 的容易程度，和测试的隔离性。至于测试的自动性，可重复性，非偶然性，无序性，完备性(全覆盖)，轻量性(可快速执行)，一般开发人员，加上 JUnit 等工具的辅助基本都能做到，也能理解它的好处，只是工作量问题。这里要特别强调的是测试用例的单一性(只测目标类本身)和隔离性(不传染失败)。现在的测试代码，过于强调完备性，大量重复交叉测试，看起来没啥坏处，但测试代码越多，维护代价越高。经常出现的问题是，修改一行代码或加一个判断条件，引起 100 多个测试用例不通过。时间一紧，谁有这个闲功夫去改这么多形态各异的测试用例？久而久之，这个测试代码就已经不能真实反应代码现在的状况，很多时候会被迫绕过。最好的情况是，修改一行代码，有且只有一行测试代码不通过。如果修改了代码而测试用例还能通过，那也不行，表示测试没有覆盖到。另外，可 Mock 性是隔离的基础，把间接依赖的逻辑屏蔽掉。可 Mock 性的一个最大的杀手就是静态方法，尽量少用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分布式服务框架维护人员增多或变更，会出现质量的下降的问题，尤其是框架代码，要时刻牢记的细节。可能下面要讲的这些，大家都会觉得很简单，很基础，但要做到时刻牢记。在每一行代码中都考虑这些因素，是需要很大耐心的。&lt;/p&gt;
&lt;h3 id=&quot;防止空指针和下标越界&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="技术规范" scheme="https://github.com/lemon-china/categories/%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="springboot" scheme="https://github.com/lemon-china/tags/springboot/"/>
    
      <category term="cloud" scheme="https://github.com/lemon-china/tags/cloud/"/>
    
      <category term="分布式" scheme="https://github.com/lemon-china/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于consul注册中心实现cloud微服务框架</title>
    <link href="https://github.com/lemon-china/2019/09/01/cloud-guid/"/>
    <id>https://github.com/lemon-china/2019/09/01/cloud-guid/</id>
    <published>2019-09-01T02:10:12.000Z</published>
    <updated>2019-09-07T05:18:18.458Z</updated>
    
    <content type="html"><![CDATA[<p>基于consul注册中心实现微服务框架，使用consul替代eureka和git config模式</p><p>本项目预启动时间为2019-03-01，实现以下内容：</p><h4 id="开发计划"><a href="#开发计划" class="headerlink" title="开发计划"></a>开发计划<br></h4><p>v0.1版本 整体服务结构划分，服务边界设定<br><br>v0.2版本 服务网关授权模式搭建<br><br>v0.3版本 前后端技术框架接入<br><br>v0.4版本 服务开发技术规范文档<br><br>v0.5版本 用户基础服务功能<br></p><h4 id="服务架构总览"><a href="#服务架构总览" class="headerlink" title="服务架构总览"></a>服务架构总览<br></h4><p>center  服务综合管理中心 <br><br>&ensp;|—  lemon-gateway  服务网关 <br><br>&ensp;|—  lemon-monitor  服务监控 <br><br>&ensp;|  <br></p><p>commons  服务基础组件中心 <br><br>&ensp;|—  lemon-common  服务通用组件 <br><br>&ensp;|—  lemon-distribution  分布业务锁&amp;任务锁 <br><br>&ensp;|—  lemon-framework  服务基础功能类包 <br><br>&ensp;|—  lemon-rabbit  服务Rabbit功能统一封装组件 <br><br>&ensp;|—  lemon-sharding  数据库分库分表封装组件 <br></p><p>services  微服务中心 <br><br>&ensp;|—  lemon-auth  授权&amp;鉴权服务 <br><br>&ensp;|—  lemon-user  用户服务 <br><br>&ensp;|—  lemon-xxx    <br><br>&ensp;|  <br></p><h4 id="服务项目结构约定"><a href="#服务项目结构约定" class="headerlink" title="服务项目结构约定"></a>服务项目结构约定<br></h4><p>1、服务名由lemon-{xxxx}组成，xxxx为相关微服务的业务名称<br></p><p>2、每个服务脚手架组件包含如下：<br></p><table><thead><tr><th>NO.</th><th>Package</th><th>Desc</th></tr></thead><tbody><tr><td>1</td><td>cn.lemon.{xxxx}.api.rest</td><td>提供对外服务rest接口</td></tr><tr><td>2</td><td>cn.lemon.{xxxx}.api.rpc</td><td>提供对内服务rpc接口</td></tr><tr><td>3</td><td>cn.lemon.{xxxx}.config</td><td>提供服务配置相关</td></tr><tr><td>4</td><td>cn.lemon.{xxxx}.entity.enums</td><td>提供业务枚举类</td></tr><tr><td>5</td><td>cn.lemon.{xxxx}.entity.po</td><td>提供数据库映射实体</td></tr><tr><td>6</td><td>cn.lemon.{xxxx}.entity.vo</td><td>提供对外接口映射实体</td></tr><tr><td>7</td><td>cn.lemon.{xxxx}.rpc.client</td><td>提供对内服务rpc调用接口 (api层不能调用rpc接口)</td></tr><tr><td>8</td><td>cn.lemon.{xxxx}.rpc.client.fallback</td><td>提供对内服务rpc调用失败业务处理</td></tr><tr><td>9</td><td>cn.lemon.{xxxx}.service</td><td>提供业务逻辑接口 (api层调用业务接口)</td></tr><tr><td>10</td><td>cn.lemon.{xxxx}.service.impl</td><td>提供业务逻辑实现</td></tr><tr><td>11</td><td>cn.lemon.{xxxx}.dao</td><td>提供数据库操作</td></tr><tr><td>12</td><td>cn.lemon.{xxxx}.events.pub</td><td>提供MQ发送事件</td></tr><tr><td>13</td><td>cn.lemon.{xxxx}.events.sub</td><td>提供MQ接收事件</td></tr><tr><td>14</td><td>cn.lemon.{xxxx}.task</td><td>提供任务定时执行逻辑</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基于consul注册中心实现微服务框架，使用consul替代eureka和git config模式&lt;/p&gt;
&lt;p&gt;本项目预启动时间为2019-03-01，实现以下内容：&lt;/p&gt;
&lt;h4 id=&quot;开发计划&quot;&gt;&lt;a href=&quot;#开发计划&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="技术架构" scheme="https://github.com/lemon-china/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="springboot" scheme="https://github.com/lemon-china/tags/springboot/"/>
    
      <category term="cloud" scheme="https://github.com/lemon-china/tags/cloud/"/>
    
      <category term="consul" scheme="https://github.com/lemon-china/tags/consul/"/>
    
      <category term="java" scheme="https://github.com/lemon-china/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>乐檬框架之rabbitMQ的解耦实现方式（基于springboot框架）</title>
    <link href="https://github.com/lemon-china/2017/05/01/lemon-rabbitmq/"/>
    <id>https://github.com/lemon-china/2017/05/01/lemon-rabbitmq/</id>
    <published>2017-05-01T02:34:12.000Z</published>
    <updated>2019-09-07T05:18:23.846Z</updated>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/lemon-china/lemon-rabbitmq">lemon-rabbitmq</a></p><p>lemon-rabbitmq   消息生产端</p><p>lemon-rabbitmq-protocol   消息协议层</p><p>lemon-rabbitmq-consumer   消息消费端</p><hr><h4 id="消息协议层"><a href="#消息协议层" class="headerlink" title="消息协议层"></a>消息协议层</h4><p>通过Jackson2序列化/反序列化，实现消息传递和对象接收</p><h4 id="消息生产端"><a href="#消息生产端" class="headerlink" title="消息生产端"></a>消息生产端</h4><p>1、通过发送带有消费端服务类名称和方法请求头，控制消费端调用执行消费发送的信息</p><p>2、利用消息回调接口ConfirmCallback确保消息安全发送至broker服务器，处理效率比事物方式更高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">final</span> String serviceName, <span class="keyword">final</span> String serviceMethodName,<span class="keyword">final</span> String correlationId, Object request)</span> </span>&#123;</span><br><span class="line">   logger.info(<span class="string">"sendMessage [this.&#123;&#125;, serviceMethodName:&#123;&#125; serviceName:&#123;&#125; correlationId: &#123;&#125;]"</span>, <span class="keyword">this</span>.getClass(), serviceMethodName, serviceName, correlationId);</span><br><span class="line">   rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">   rabbitTemplate.setCorrelationKey(correlationId);</span><br><span class="line">   rabbitTemplate.convertAndSend(routingkey, request, <span class="keyword">new</span> MessagePostProcessor() &#123;            </span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">              message.getMessageProperties().setAppId(appId);</span><br><span class="line">              message.getMessageProperties().setTimestamp(<span class="keyword">new</span> Date());</span><br><span class="line">              message.getMessageProperties().setMessageId(UUID.randomUUID().toString());</span><br><span class="line">              message.getMessageProperties().setCorrelationId(correlationId.getBytes());</span><br><span class="line">              message.getMessageProperties().setHeader(<span class="string">"ServiceMethodName"</span>, serviceMethodName);</span><br><span class="line">              message.getMessageProperties().setHeader(<span class="string">"ServiceName"</span>, serviceName);</span><br><span class="line">              <span class="keyword">return</span> message;</span><br><span class="line">          &#125;</span><br><span class="line">   &#125;, <span class="keyword">new</span> CorrelationData(correlationId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="消息消费端"><a href="#消息消费端" class="headerlink" title="消息消费端"></a>消息消费端</h4><p>1、监听MQ消息，利用method.invoke调用指定的服务类名称和方法，消费接收到的消息</p><p>2、使用Ack/Nack手动确认消息处理状态，保证broker消息被正确消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"----- received"</span> + message.getMessageProperties());</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object msg = messageConverter.fromMessage(message);</span><br><span class="line"><span class="keyword">if</span> (!appId.equals(message.getMessageProperties().getAppId()))&#123;</span><br><span class="line">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"非法应用appId:"</span> + message.getMessageProperties().getAppId());</span><br><span class="line">&#125;</span><br><span class="line">Object service = ctx.getBean(message.getMessageProperties().getHeaders().get(<span class="string">"ServiceName"</span>).toString());</span><br><span class="line">String serviceMethodName = message.getMessageProperties().getHeaders().get(<span class="string">"ServiceMethodName"</span>).toString();</span><br><span class="line">Method method = service.getClass().getMethod(serviceMethodName, msg.getClass());</span><br><span class="line">       method.invoke(service, msg);</span><br><span class="line">       <span class="comment">//确认消息成功消费</span></span><br><span class="line">       channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123;</span><br><span class="line">System.out.println(<span class="string">"------ err"</span>+ e.getMessage());</span><br><span class="line">       channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/lemon-china/lemon-rabbitmq&quot;&gt;lemon-rabbitmq&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;lemon-rabbitmq   消息生产端&lt;/p&gt;
&lt;p&gt;lemon-rabbitmq-proto
      
    
    </summary>
    
    
      <category term="技术架构" scheme="https://github.com/lemon-china/categories/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="springboot" scheme="https://github.com/lemon-china/tags/springboot/"/>
    
      <category term="java" scheme="https://github.com/lemon-china/tags/java/"/>
    
      <category term="rabbitmq" scheme="https://github.com/lemon-china/tags/rabbitmq/"/>
    
      <category term="ack/nack" scheme="https://github.com/lemon-china/tags/ack-nack/"/>
    
  </entry>
  
</feed>
