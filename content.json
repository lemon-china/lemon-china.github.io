{"meta":{"title":"lemon-china","subtitle":"乐檬·中国致力于打造最优雅的系统框架","description":"乐檬·中国致力于打造最优雅的系统框架","author":"lemon-china","url":"https://github.com/lemon-china","root":"/"},"pages":[{"title":"archives","date":"2019-09-07T02:43:41.000Z","updated":"2019-09-07T07:37:44.969Z","comments":true,"path":"archives/index.html","permalink":"https://github.com/lemon-china/archives/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-09-07T03:53:31.000Z","updated":"2019-09-07T13:19:13.083Z","comments":false,"path":"links/index.html","permalink":"https://github.com/lemon-china/links/index.html","excerpt":"","text":"柴伙二维码平台柴伙二维码云平台，汇聚全国100万精品微信小程序、微信群二维码、微信红包群、陌陌、QQ、个人号、群组及公众号等二维码发布推广，为用户提供一个安全、靠谱的互联网应用导航商店和商务合作推广平台。 阿里云计算平台阿里云是阿里巴巴集团旗下公司，是全球领先的云计算及人工智能科技公司。提供云服务器、云数据库、云安全、企业应用等云计算服务，以及大数据、人工智能解决方案，精准定制基于场景的行业解决方案。 微信公众平台微信公众平台，给个人、企业和组织提供业务服务与用户管理能力的全新服务平台。 融云互联网通信云服务商融云是安全、可靠的全球互联网通信云服务商，向开发者和企业提供即时通讯和实时音视频通信云服务。融云可提供多种部署模式：公有云、私有云及混合云，服务覆盖全球所有国家及地区。已有25万开发者和上千家企业用户通过融云实现了场景化沟通。 友盟数据智能服务商友盟是国内领先的第三方全域数据智能服务商。专注为互联网企业提供一站式数据分析运营服务近10年。为开发者提供更灵活、更智能、更专业的数据采集、分析、管理功能，AI赋能业务增长。"},{"title":"分类","date":"2019-09-07T06:11:44.000Z","updated":"2019-09-07T07:02:14.062Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/lemon-china/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-09-07T06:20:06.000Z","updated":"2019-09-07T07:02:07.740Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/lemon-china/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"设计实现的健壮性","slug":"exp_1113","date":"2019-09-07T14:30:31.000Z","updated":"2019-09-07T13:54:33.952Z","comments":true,"path":"2019/09/07/exp_1113/","link":"","permalink":"https://github.com/lemon-china/2019/09/07/exp_1113/","excerpt":"","text":"日志日志是发现问题、查看问题一个最常用的手段。日志质量往往被忽视，没有日志使用上的明确约定。重视 Log 的使用，提高 Log 的信息浓度。日志过多、过于混乱，会导致有用的信息被淹没。 要有效利用这个工具要注意： 严格约定WARN、ERROR级别记录的内容WARN 表示可以恢复的问题，无需人工介入。ERROR 表示需要人工介入问题。有了这样的约定，监管系统发现日志文件的中出现 ERROR 字串就报警，又尽量减少了发生。过多的报警会让人疲倦，使人对报警失去警惕性，使 ERROR 日志失去意义。再辅以人工定期查看 WARN 级别信息，以评估系统的“亚健康”程度。 日志中，尽量多的收集关键信息出问题时的现场信息，即排查问题要用到的信息。如服务调用失败时，要给出使用 Dubbo 的版本、服务提供者的 IP、使用的是哪个注册中心；调用的是哪个服务、哪个方法等等。这些信息如果不给出，那么事后人工收集的，问题过后现场可能已经不能复原，加大排查问题的难度。如果可能，给出问题的原因和解决方法。这让维护和问题解决变得简单，而不是寻求精通者（往往是实现者）的帮助。 同一个或是一类问题不要重复记录多次同一个或是一类异常日志连续出现几十遍的情况，还是常常能看到的。人眼很容易漏掉淹没在其中不一样的重要日志信息。要尽量避免这种情况。在可以预见会出现的情况，有必要加一些逻辑来避免。 如为一个问题准备一个标志，出问题后打日志后设置标志，避免重复打日志。问题恢复后清除标志。 虽然有点麻烦，但是这样做保证日志信息浓度，让监控更有效。 界限设置资源是有限的，CPU、内存、IO 等等。不要因为外部的请求、数据不受限的而崩溃。 线程池(ExectorService)的大小和饱和策略Server 端用于处理请求的 ExectorService 设置上限。ExecutorService 的任务等待队列使用有限队列，避免资源耗尽。当任务等待队列饱和时，选择一个合适的饱和策略。这样保证平滑劣化。 在一些设计中，饱和策略是丢弃数据，等待结果也只是请求的超时。 达到饱和时，说明已经达到服务提供方的负荷上限，要在饱和策略的操作中日志记录这个问题，以发出监控警报。记得注意不要重复多次记录哦。（注意，缺省的饱和策略不会有这些附加的操作。）根据警报的频率，已经决定扩容调整等等，避免系统问题被忽略。 集合容量如果确保进入集合的元素是可控的且是足够少，则可以放心使用。这是大部分的情况。如果不能保证，则使用有有界的集合。当到达界限时，选择一个合适的丢弃策略。 容错-重试-恢复高可用组件要容忍其依赖组件的失败。 服务注册中心目前服务注册中心使用了数据库来保存服务提供者和消费者的信息。注册中心集群不同注册中心也通过数据库来进行同步数据，以感知其它注册中心上提供者的变化。注册中心会在内存中保存一份提供者和消费者数据，数据库不可用时，注册中心独立对外提供服务以保证正常运转，只是拿不到其它注册中心的数据。当数据库恢复时，重试逻辑会将内存中修改的数据写回数据库，并拿到数据库中新数据。 服务的消费者服务消费者从注册中心拿到提供者列表后，会保存提供者列表到内存和磁盘文件中。这样注册中心宕机后消费者可以正常运转，甚至可以在注册中心宕机过程中重启消费者。消费者启动时，发现注册中心不可用，会读取保存在磁盘文件中提供者列表。重试逻辑保证注册中心恢复后，更新信息。 重试延迟策略数据库上的活锁注册中心会定时更新数据库一条记录的时间戳，这样集群中其它的注册中心感知它是存活。过期注册中心和它的相关数据 会被清除。数据库正常时，这个机制运行良好。但是数据库负荷高时，其上的每个操作都会很慢。这就出现： A 注册中心认为 B 过期，删除 B 的数据。 B 发现自己的数据没有了，重新写入自己的数据的反复操作。这些反复的操作又加重了数据库的负荷，恶化问题。 可以使用下面逻辑：当 B 发现自己数据被删除时（写入失败），选择等待这段时间再重试。重试时间可以选择指数级增长，如第一次等 1 分钟，第二次 10 分钟、第三次 100 分钟。 这样操作减少后，保证数据库可以冷却（Cool Down）下来。 Client 重连注册中心当一个注册中心停机时，其它的 Client 会同时接收事件，而去重连另一个注册中心。Client 数量相对比较多，会对注册中心造成冲击。避免方法可以是 Client 重连时随机延时 3 分钟，把重连分散开。","categories":[{"name":"经验分享","slug":"经验分享","permalink":"https://github.com/lemon-china/categories/经验分享/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://github.com/lemon-china/tags/微服务/"},{"name":"spring","slug":"spring","permalink":"https://github.com/lemon-china/tags/spring/"},{"name":"架构设计","slug":"架构设计","permalink":"https://github.com/lemon-china/tags/架构设计/"}]},{"title":"乐檬框架之cloud微服务框架","slug":"doc_1112","date":"2019-09-06T10:34:12.000Z","updated":"2019-09-07T13:42:53.137Z","comments":true,"path":"2019/09/06/doc_1112/","link":"","permalink":"https://github.com/lemon-china/2019/09/06/doc_1112/","excerpt":"","text":"基于consul注册中心实现微服务框架，使用consul替代eureka和git config模式 项目地址：lemon-consul-cloud 本项目预启动时间为2019-03-01，实现以下内容： 开发计划12345v0.1版本 整体服务结构划分，服务边界设定v0.2版本 服务网关授权模式搭建v0.3版本 前后端技术框架接入v0.4版本 服务开发技术规范文档v0.5版本 用户基础服务功能 服务框架总览 lemon-gateway 服务网关 lemon-monitor 服务监控 commons 服务基础组件中心 lemon-common 服务通用组件 lemon-distribution 分布业务锁&amp;任务锁 lemon-framework 服务基础功能类包 lemon-rabbit 服务Rabbit功能统一封装组件 lemon-sharding 数据库分库分表封装组件 services 微服务中心 lemon-auth 授权&amp;鉴权服务 lemon-user 用户服务 lemon-xxx 服务划分说明明确划分每个服务的功能 NO. Module Name Desc 1 lemon-auth 授权服务 用户授权中心管理 2 lemon-user 用户服务 用户信息中心服务 3 lemon-payment 账务服务 用户交易中心服务 4 lemon-adjust 核算服务 账户核算中心服务 5 lemon-message 消息服务 用户消息中心服务 服务项目结构约定 NO. Package Desc 1 cn.lemon.{xxxx}.api.rest 提供对外服务rest接口 2 cn.lemon.{xxxx}.api.rpc 提供对内服务rpc接口 3 cn.lemon.{xxxx}.config 提供服务配置相关 4 cn.lemon.{xxxx}.entity.enums 提供业务枚举类 5 cn.lemon.{xxxx}.entity.po 提供数据库映射实体 6 cn.lemon.{xxxx}.entity.vo 提供对外接口映射实体 7 cn.lemon.{xxxx}.rpc.client 提供对内服务rpc调用接口 (api层不能调用rpc接口) 8 cn.lemon.{xxxx}.rpc.client.fallback 提供对内服务rpc调用失败业务处理 9 cn.lemon.{xxxx}.service 提供业务逻辑接口 (api层调用业务接口) 10 cn.lemon.{xxxx}.service.impl 提供业务逻辑实现 11 cn.lemon.{xxxx}.dao 提供数据库操作 12 cn.lemon.{xxxx}.events.pub 提供MQ发送事件 13 cn.lemon.{xxxx}.events.sub 提供MQ接收事件 14 cn.lemon.{xxxx}.task 提供任务定时执行逻辑","categories":[{"name":"开源文档","slug":"开源文档","permalink":"https://github.com/lemon-china/categories/开源文档/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"cloud","slug":"cloud","permalink":"https://github.com/lemon-china/tags/cloud/"},{"name":"consul","slug":"consul","permalink":"https://github.com/lemon-china/tags/consul/"},{"name":"lemon","slug":"lemon","permalink":"https://github.com/lemon-china/tags/lemon/"}]},{"title":"代码习惯在细节","slug":"exp_1112","date":"2019-09-05T07:12:12.000Z","updated":"2019-09-07T13:51:47.743Z","comments":true,"path":"2019/09/05/exp_1112/","link":"","permalink":"https://github.com/lemon-china/2019/09/05/exp_1112/","excerpt":"","text":"分布式服务框架维护人员增多或变更，会出现质量的下降的问题，尤其是框架代码，要时刻牢记的细节。可能下面要讲的这些，大家都会觉得很简单，很基础，但要做到时刻牢记。在每一行代码中都考虑这些因素，是需要很大耐心的。 防止空指针和下标越界这是我最不喜欢看到的异常，尤其在核心框架中，我更愿看到信息详细的参数不合法异常。这也是一个编写健壮程序的开发人员，在写每一行代码都应在潜意识中防止的异常。基本上要能确保每一次写完的代码，在不测试的情况下，都不会出现这两个异常才算合格。 保证线程安全性和可见性对于框架的开发人员，对线程安全性和可见性的深入理解是最基本的要求。需要开发人员，在写每一行代码时都应在潜意识中确保其正确性。因为这种代码，在小并发下做功能测试时，会显得很正常。但在高并发下就会出现莫明其妙的问题，而且场景很难重现，极难排查。 尽早失败和前置断言尽早失败也应该成为潜意识，在有传入参数和状态变化时，均在入口处全部断言。一个不合法的值和状态，在第一时间就应报错，而不是等到要用时才报错。因为等到要用时，可能前面已经修改其它相关状态，而在程序中很少有人去处理回滚逻辑。这样报错后，其实内部状态可能已经混乱，极易在一个隐蔽分支上引发程序不可恢复。 分离可靠操作和不可靠操作这里的可靠是狭义的指是否会抛出异常或引起状态不一致，比如，写入一个线程安全的 Map，可以认为是可靠的，而写入数据库等，可以认为是不可靠的。开发人员必须在写每一行代码时，都注意它的可靠性与否，在代码中尽量划分开，并对失败做异常处理，并为容错，自我保护，自动恢复或切换等补偿逻辑提供清晰的切入点，保证后续增加的代码不至于放错位置，而导致原先的容错处理陷入混乱。 异常防御，但不忽略异常这里讲的异常防御，指的是对非必须途径上的代码进行最大限度的容忍，包括程序上的 BUG，比如：获取程序的版本号，会通过扫描 Manifest 和 jar 包名称抓取版本号，这个逻辑是辅助性的，但代码却不少，初步测试也没啥问题，但应该在整个 getVersion() 中加上一个全函数的 try-catch 打印错误日志，并返回基本版本，因为 getVersion() 可能存在未知特定场景异常，或被其他的开发人员误修改逻辑(但一般人员不会去掉 try-catch)，而如果它抛出异常会导致主流程异常，这是我们不希望看到的。但这里要控制个度，不要随意 try-catch，更不要无声无息的吃掉异常。 缩小可变域和尽量 final如果一个类可以成为不变类(Immutable Class)，就优先将它设计成不变类。不变类有天然的并发共享优势，减少同步或复制，而且可以有效帮忙分析线程安全的范围。就算是可变类，对于从构造函数传入的引用，在类中持有时，最好将字段 final，以免被中途误修改引用。不要以为这个字段是私有的，这个类的代码都是我自己写的，不会出现对这个字段的重新赋值。要考虑的一个因素是，这个代码可能被其他人修改，他不知道你的这个弱约定，final 就是一个不变契约。 降低修改时的误解性，不埋雷前面不停的提到代码被其他人修改，这也开发人员要随时紧记的。这个其他人包括未来的自己，你要总想着这个代码可能会有人去改它。我应该给修改的人一点什么提示，让他知道我现在的设计意图，而不要在程序里面加潜规则，或埋一些容易忽视的雷，比如：你用 null 表示不可用，size 等于 0 表示黑名单，这就是一个雷，下一个修改者，包括你自己，都不会记得有这样的约定，可能后面为了改某个其它 BUG，不小心改到了这里，直接引爆故障。对于这个例子，一个原则就是永远不要区分 null 引用和 empty 值。 提高代码的可测性这里的可测性主要指 Mock 的容易程度，和测试的隔离性。至于测试的自动性，可重复性，非偶然性，无序性，完备性(全覆盖)，轻量性(可快速执行)，一般开发人员，加上 JUnit 等工具的辅助基本都能做到，也能理解它的好处，只是工作量问题。这里要特别强调的是测试用例的单一性(只测目标类本身)和隔离性(不传染失败)。现在的测试代码，过于强调完备性，大量重复交叉测试，看起来没啥坏处，但测试代码越多，维护代价越高。经常出现的问题是，修改一行代码或加一个判断条件，引起 100 多个测试用例不通过。时间一紧，谁有这个闲功夫去改这么多形态各异的测试用例？久而久之，这个测试代码就已经不能真实反应代码现在的状况，很多时候会被迫绕过。最好的情况是，修改一行代码，有且只有一行测试代码不通过。如果修改了代码而测试用例还能通过，那也不行，表示测试没有覆盖到。另外，可 Mock 性是隔离的基础，把间接依赖的逻辑屏蔽掉。可 Mock 性的一个最大的杀手就是静态方法，尽量少用。","categories":[{"name":"经验分享","slug":"经验分享","permalink":"https://github.com/lemon-china/categories/经验分享/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"cloud","slug":"cloud","permalink":"https://github.com/lemon-china/tags/cloud/"},{"name":"分布式","slug":"分布式","permalink":"https://github.com/lemon-china/tags/分布式/"}]},{"title":"XXL-JOB分布式任务快速入门","slug":"stu_1111","date":"2019-09-04T07:21:11.000Z","updated":"2019-09-07T13:07:34.938Z","comments":true,"path":"2019/09/04/stu_1111/","link":"","permalink":"https://github.com/lemon-china/2019/09/04/stu_1111/","excerpt":"","text":"XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 项目地址：xxl-job分布式任务调度平台 模块 调度中心 xxl-job-admin 公共依赖 xxl-job-core 任务执行器 opay-xxx 集群 调度中心集群 DB配置保持一致 登陆账号配置保持一致 集群机器时钟保持一致建议：推荐通过nginx为调度中心集群做负载均衡，分配域名 调度中心访问、执行器回调配置、调用API服务等操作均通过该域名进行。 执行器集群 执行器回调地址保持一致xxl.job.admin.addresses 执行器集群内AppName保持一致xxl.job.executor.appname​ 任务关键点 执行器 任务描述 路由策略 FIRST（第一个）固定选择第一个机器 LAST（最后一个）固定选择最后一个机器 ROUND（轮询） RANDOM（随机）随机选择在线的机器 CONSISTENT_HASH（一致性HASH）每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上 LEAST_FREQUENTLY_USED（最不经常使用）使用频率最低的机器优先被选举 LEAST_RECENTLY_USED（最近最久未使用）最久为使用的机器优先被选举 FAILOVER（故障转移）按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度 BUSYOVER（忙碌转移）按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度 SHARDING_BROADCAST(分片广播)广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数，可根据分片参数开发分片任务 Cron表达式 运行模式 BEAN GLUE JobHandler任务bean名称@JobHandler 阻塞策略 单机串行进入单机执行器后，进入FIFO队列并以串行方式运行 丢弃后续调度进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败 覆盖之前调度进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列 负责人 其他 子任务ID 超时时间 重试次数 报警邮件 任务参数 注意事项 日志文件目录需要权限默认 /data/applogs/xxl-job/jobhandler​ 设置日志保存天数xxl.job.executor.logretentiondays=-1 //大于3生效 执行日志需要通过 “XxlJobLogger.log” 打印执行日志 admin执行任务时报错 Communications link failure数据库链接地址加上 &amp;autoReconnect=true&amp;failOverReadOnly=false","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/lemon-china/categories/学习笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"},{"name":"开源工具","slug":"开源工具","permalink":"https://github.com/lemon-china/tags/开源工具/"},{"name":"定时任务","slug":"定时任务","permalink":"https://github.com/lemon-china/tags/定时任务/"}]},{"title":"XXL-JOB分布式任务调度平台","slug":"tool_1112","date":"2019-09-03T05:23:12.000Z","updated":"2019-09-07T13:07:38.251Z","comments":true,"path":"2019/09/03/tool_1112/","link":"","permalink":"https://github.com/lemon-china/2019/09/03/tool_1112/","excerpt":"","text":"XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 项目地址：xxl-job分布式任务调度平台 简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手； 动态：支持动态修改任务状态、启动/停止任务，以及终止运行中任务，即时生效； 调度中心HA（中心式）：调度采用中心式设计，“调度中心”自研调度组件并支持集群部署，可保证调度中心HA； 执行器HA（分布式）：任务分布式执行，任务”执行器”支持集群部署，可保证任务执行HA； 注册中心: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址； 弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务； 路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等； 故障转移：任务路由策略选择”故障转移”情况下，如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求。 阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度； 任务超时控制：支持自定义任务超时时间，任务运行超时将会主动中断任务； 任务失败重试：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；其中分片任务支持分片粒度的失败重试； 任务失败告警；默认提供邮件方式失败告警，同时预留扩展接口，可方便的扩展短信、钉钉等告警方式； 分片广播任务：执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务； 动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。 事件触发：除了”Cron方式”和”任务依赖方式”触发任务执行之外，支持基于事件的触发任务方式。调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发。 任务进度监控：支持实时监控任务进度； Rolling实时日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志； GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。 脚本任务：支持以GLUE模式开发和运行脚本任务，包括Shell、Python、NodeJS、PHP、PowerShell等类型脚本; 命令行任务：原生提供通用命令行任务Handler（Bean任务，”CommandJobHandler”）；业务方只需要提供命令行即可； 任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行, 多个子任务用逗号分隔； 一致性：“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行； 自定义任务参数：支持在线配置调度任务入参，即时生效； 调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞； 数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性； 邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件； 推送maven中央仓库: 将会把最新稳定版推送到maven中央仓库, 方便用户接入和使用; 运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等； 全异步：任务调度流程全异步化设计实现，如异步调度、异步运行、异步回调等，有效对密集调度进行流量削峰，理论上支持任意时长任务的运行； 跨平台：原生提供通用HTTP任务Handler（Bean任务，”HttpJobHandler”）；业务方只需要提供HTTP链接即可，不限制语言、平台； 国际化：调度中心支持国际化设置，提供中文、英文两种可选语言，默认为中文； 容器化：提供官方docker镜像，并实时更新推送dockerhub，进一步实现产品开箱即用； 线程池隔离：调度线程池进行隔离拆分，慢任务自动降级进入”Slow”线程池，避免耗尽调度线程，提高系统稳定性； 用户管理：支持在线管理系统用户，存在管理员、普通用户两种角色； 权限控制：执行器维度进行权限控制，管理员拥有全量权限，普通用户需要分配执行器权限后才允许相关操作。","categories":[{"name":"常用工具","slug":"常用工具","permalink":"https://github.com/lemon-china/categories/常用工具/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"},{"name":"开源工具","slug":"开源工具","permalink":"https://github.com/lemon-china/tags/开源工具/"},{"name":"定时任务","slug":"定时任务","permalink":"https://github.com/lemon-china/tags/定时任务/"}]},{"title":"服务开发核心思想","slug":"exp_1111","date":"2019-09-03T04:30:12.000Z","updated":"2019-09-07T13:51:42.936Z","comments":true,"path":"2019/09/03/exp_1111/","link":"","permalink":"https://github.com/lemon-china/2019/09/03/exp_1111/","excerpt":"","text":"保障服务可扩展性的七大原则1、按功能划分 2、水平切分 3、尽量避免事务 4、适当采用异步解耦 5、次流程改进为异步 6、虚拟化所有层次 7、适当使用缓存 服务拆分开发的四项原则1、先业务后技术，先逻辑后物理 2、奥卡姆剃刀：如无必须勿增实体 3、正交性：抽象出模块间无业务相关的重复代码 4、稳定性原则：服务的稳定性优先，通过拆分解耦 可参考的技术方案：接口化、消息队列、模块化、服务化、异步化","categories":[{"name":"经验分享","slug":"经验分享","permalink":"https://github.com/lemon-china/categories/经验分享/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"cloud","slug":"cloud","permalink":"https://github.com/lemon-china/tags/cloud/"},{"name":"分布式","slug":"分布式","permalink":"https://github.com/lemon-china/tags/分布式/"}]},{"title":"Apollo分布式配置中心快速入门","slug":"stu_1112","date":"2019-09-02T04:21:22.000Z","updated":"2019-09-07T13:31:36.409Z","comments":true,"path":"2019/09/02/stu_1112/","link":"","permalink":"https://github.com/lemon-china/2019/09/02/stu_1112/","excerpt":"","text":"Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。 项目地址：apollo分布式配置中心 关键词 AppId ENV Cluster Namespace Public Private 关联(继承) 操作点 发布 回滚 灰度 创建Cluster 创建/关联Namespace 核心点 项目AppId 宿主机ENV apollo.meta Private AppId Public Share 可多Namespace Public关联 / 覆盖","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/lemon-china/categories/学习笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"},{"name":"开源工具","slug":"开源工具","permalink":"https://github.com/lemon-china/tags/开源工具/"},{"name":"定时任务","slug":"定时任务","permalink":"https://github.com/lemon-china/tags/定时任务/"},{"name":"apollo","slug":"apollo","permalink":"https://github.com/lemon-china/tags/apollo/"}]},{"title":"乐檬框架之rabbitMQ的解耦实现方式","slug":"doc_1111","date":"2019-09-02T02:34:12.000Z","updated":"2019-09-07T13:25:31.189Z","comments":true,"path":"2019/09/02/doc_1111/","link":"","permalink":"https://github.com/lemon-china/2019/09/02/doc_1111/","excerpt":"","text":"项目地址：lemon-rabbitmq lemon-rabbitmq 消息生产端 lemon-rabbitmq-protocol 消息协议层 lemon-rabbitmq-consumer 消息消费端 消息协议层通过Jackson2序列化/反序列化，实现消息传递和对象接收 消息生产端1、通过发送带有消费端服务类名称和方法请求头，控制消费端调用执行消费发送的信息 2、利用消息回调接口ConfirmCallback确保消息安全发送至broker服务器，处理效率比事物方式更高 1234567891011121314151617public void sendMessage(final String serviceName, final String serviceMethodName,final String correlationId, Object request) &#123; logger.info(\"sendMessage [this.&#123;&#125;, serviceMethodName:&#123;&#125; serviceName:&#123;&#125; correlationId: &#123;&#125;]\", this.getClass(), serviceMethodName, serviceName, correlationId); rabbitTemplate.setConfirmCallback(this); rabbitTemplate.setCorrelationKey(correlationId); rabbitTemplate.convertAndSend(routingkey, request, new MessagePostProcessor() &#123; @Override public Message postProcessMessage(Message message) throws AmqpException &#123; message.getMessageProperties().setAppId(appId); message.getMessageProperties().setTimestamp(new Date()); message.getMessageProperties().setMessageId(UUID.randomUUID().toString()); message.getMessageProperties().setCorrelationId(correlationId.getBytes()); message.getMessageProperties().setHeader(\"ServiceMethodName\", serviceMethodName); message.getMessageProperties().setHeader(\"ServiceName\", serviceName); return message; &#125; &#125;, new CorrelationData(correlationId));&#125; 消息消费端1、监听MQ消息，利用method.invoke调用指定的服务类名称和方法，消费接收到的消息 2、使用Ack/Nack手动确认消息处理状态，保证broker消息被正确消费 12345678910111213141516171819public void onMessage(Message message, Channel channel) throws IOException &#123; System.out.println(\"----- received\" + message.getMessageProperties()); try &#123; Object msg = messageConverter.fromMessage(message); if (!appId.equals(message.getMessageProperties().getAppId()))&#123; channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); throw new SecurityException(\"非法应用appId:\" + message.getMessageProperties().getAppId()); &#125; Object service = ctx.getBean(message.getMessageProperties().getHeaders().get(\"ServiceName\").toString()); String serviceMethodName = message.getMessageProperties().getHeaders().get(\"ServiceMethodName\").toString(); Method method = service.getClass().getMethod(serviceMethodName, msg.getClass()); method.invoke(service, msg); //确认消息成功消费 channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); &#125; catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123; System.out.println(\"------ err\"+ e.getMessage()); channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); &#125;&#125;","categories":[{"name":"开源文档","slug":"开源文档","permalink":"https://github.com/lemon-china/categories/开源文档/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"},{"name":"mq","slug":"mq","permalink":"https://github.com/lemon-china/tags/mq/"},{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"ack/nack","slug":"ack-nack","permalink":"https://github.com/lemon-china/tags/ack-nack/"}]},{"title":"Hutool工具包类库","slug":"tool_1111","date":"2019-09-01T12:33:12.000Z","updated":"2019-09-07T13:07:45.443Z","comments":true,"path":"2019/09/01/tool_1111/","link":"","permalink":"https://github.com/lemon-china/2019/09/01/tool_1111/","excerpt":"","text":"Hutool是一个Java工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让Java语言也可以“甜甜的”。Hutool最初是我项目中“util”包的一个整理，后来慢慢积累并加入更多非业务相关功能，并广泛学习其它开源项目精髓，经过自己整理修改，最终形成丰富的开源工具集。 项目地址：hutool工具包 日期工具通过DateUtil类，提供高度便捷的日期访问、处理和转换方式。 HTTP客户端通过HttpUtil对HTTP客户端的封装，实现便捷的HTTP请求，并简化文件上传操作。 转换工具通过Convert类中的相应静态方法，提供一整套的类型转换解决方案，并通过ConverterRegistry工厂类自定义转换。 配置文件工具通过Setting对象，提供兼容Properties文件的更加强大的配置文件工具，用于解决中文、分组等JDK配置文件存在的诸多问题。 日志工具Hutool的日志功能，通过抽象Log接口，提供对Slf4j、LogBack、Log4j、JDK-Logging的全面兼容支持。 JDBC工具类通过db模块，提供对MySQL、Oracle等关系型数据库的JDBC封装，借助ActiveRecord思想，大大简化数据库操作。","categories":[{"name":"常用工具","slug":"常用工具","permalink":"https://github.com/lemon-china/categories/常用工具/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"},{"name":"开源工具","slug":"开源工具","permalink":"https://github.com/lemon-china/tags/开源工具/"},{"name":"spring","slug":"spring","permalink":"https://github.com/lemon-china/tags/spring/"}]},{"title":"开发者约定","slug":"doc_1110","date":"2019-09-01T02:10:12.000Z","updated":"2019-09-11T01:54:23.719Z","comments":true,"path":"2019/09/01/doc_1110/","link":"","permalink":"https://github.com/lemon-china/2019/09/01/doc_1110/","excerpt":"","text":"本文档约定了服务开发人员的代码规范，从而增强代码的一致性和可维护性 1、接口地址和参数严格区分大小写，接口尽量全部小写，参数使用驼峰命名； 2、接口默认以请求参数形式传入参数，响应返回JSON格式数据； 3、H5内所有资源引用打包自动带上日期版本号，防止发布版本引用资源在浏览器缓存导致功能异常（如：./jquery-1.11.0.js?v=201806051011） 4、接口请求数据均需要携带header参数： 参数名 必填 类型 说明 x-auth-token 是 string 登录后返回的token x-app-version 是 string 应用版本（固定 1.0.0） x-device 是 integer 设备类型(1：IOS 2：Android 3：wap 4: 微信 5: H5) x-device-name 是 string 设备/浏览器名称（如：huawei/Chrome） x-timestamp 是 long 10位时间戳 5、接口返回数据JSON格式标准: 参数名 类型 说明 code integer 状态码 message string 状态/错误信息 data object 返回的数据 不带返回数据示例： 1234&#123; \"message\": \"操作成功\", \"code\": \"2000\"&#125; 带返回数据示例： 123456789&#123; \"message\": \"操作成功\", \"code\": \"2000\", \"data\": &#123; \"userId\": \"1488512189\", \"nickName\": \"哈哈\", \"vip\": \"12\" &#125;&#125; 异常返回示例： 1234&#123; \"message\": \"短信验证码发送失败\", \"code\": \"6017\"&#125;","categories":[{"name":"开源文档","slug":"开源文档","permalink":"https://github.com/lemon-china/categories/开源文档/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://github.com/lemon-china/tags/微服务/"},{"name":"开发规范","slug":"开发规范","permalink":"https://github.com/lemon-china/tags/开发规范/"},{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"}]}]}