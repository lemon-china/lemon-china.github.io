{"meta":{"title":"lemon-china","subtitle":"乐檬·中国致力于打造最优雅的系统框架","description":null,"author":"lemon-china","url":"https://github.com/lemon-china","root":"/"},"pages":[{"title":"分类","date":"2019-09-07T06:11:44.000Z","updated":"2019-09-07T07:02:14.062Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/lemon-china/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-09-07T03:53:31.000Z","updated":"2019-09-07T13:19:13.083Z","comments":false,"path":"links/index.html","permalink":"https://github.com/lemon-china/links/index.html","excerpt":"","text":"柴伙二维码平台柴伙二维码云平台，汇聚全国100万精品微信小程序、微信群二维码、微信红包群、陌陌、QQ、个人号、群组及公众号等二维码发布推广，为用户提供一个安全、靠谱的互联网应用导航商店和商务合作推广平台。 阿里云计算平台阿里云是阿里巴巴集团旗下公司，是全球领先的云计算及人工智能科技公司。提供云服务器、云数据库、云安全、企业应用等云计算服务，以及大数据、人工智能解决方案，精准定制基于场景的行业解决方案。 微信公众平台微信公众平台，给个人、企业和组织提供业务服务与用户管理能力的全新服务平台。 融云互联网通信云服务商融云是安全、可靠的全球互联网通信云服务商，向开发者和企业提供即时通讯和实时音视频通信云服务。融云可提供多种部署模式：公有云、私有云及混合云，服务覆盖全球所有国家及地区。已有25万开发者和上千家企业用户通过融云实现了场景化沟通。 友盟数据智能服务商友盟是国内领先的第三方全域数据智能服务商。专注为互联网企业提供一站式数据分析运营服务近10年。为开发者提供更灵活、更智能、更专业的数据采集、分析、管理功能，AI赋能业务增长。"},{"title":"标签","date":"2019-09-07T06:20:06.000Z","updated":"2019-09-07T07:02:07.740Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/lemon-china/tags/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-09-07T02:43:41.000Z","updated":"2019-09-07T07:37:44.969Z","comments":true,"path":"archives/index.html","permalink":"https://github.com/lemon-china/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"乐檬框架之cloud微服务框架","slug":"doc_1112","date":"2019-09-06T10:34:12.000Z","updated":"2019-09-07T13:38:59.821Z","comments":true,"path":"2019/09/06/doc_1112/","link":"","permalink":"https://github.com/lemon-china/2019/09/06/doc_1112/","excerpt":"","text":"基于consul注册中心实现微服务框架，使用consul替代eureka和git config模式 项目地址：lemon-consul-cloud 本项目预启动时间为2019-03-01，实现以下内容： 开发计划12345v0.1版本 整体服务结构划分，服务边界设定v0.2版本 服务网关授权模式搭建v0.3版本 前后端技术框架接入v0.4版本 服务开发技术规范文档v0.5版本 用户基础服务功能 服务框架总览— lemon-gateway 服务网关— lemon-monitor 服务监控 commons 服务基础组件中心— lemon-common 服务通用组件— lemon-distribution 分布业务锁&amp;任务锁— lemon-framework 服务基础功能类包— lemon-rabbit 服务Rabbit功能统一封装组件— lemon-sharding 数据库分库分表封装组件 services 微服务中心— lemon-auth 授权&amp;鉴权服务— lemon-user 用户服务— lemon-xxx 服务划分说明明确划分每个服务的功能 NO. Module Name Desc 1 lemon-auth 授权服务 用户授权中心管理 2 lemon-user 用户服务 用户信息中心服务 3 lemon-payment 账务服务 用户交易中心服务 4 lemon-adjust 核算服务 账户核算中心服务 5 lemon-message 消息服务 用户消息中心服务 服务项目结构约定 NO. Package Desc 1 cn.lemon.{xxxx}.api.rest 提供对外服务rest接口 2 cn.lemon.{xxxx}.api.rpc 提供对内服务rpc接口 3 cn.lemon.{xxxx}.config 提供服务配置相关 4 cn.lemon.{xxxx}.entity.enums 提供业务枚举类 5 cn.lemon.{xxxx}.entity.po 提供数据库映射实体 6 cn.lemon.{xxxx}.entity.vo 提供对外接口映射实体 7 cn.lemon.{xxxx}.rpc.client 提供对内服务rpc调用接口 (api层不能调用rpc接口) 8 cn.lemon.{xxxx}.rpc.client.fallback 提供对内服务rpc调用失败业务处理 9 cn.lemon.{xxxx}.service 提供业务逻辑接口 (api层调用业务接口) 10 cn.lemon.{xxxx}.service.impl 提供业务逻辑实现 11 cn.lemon.{xxxx}.dao 提供数据库操作 12 cn.lemon.{xxxx}.events.pub 提供MQ发送事件 13 cn.lemon.{xxxx}.events.sub 提供MQ接收事件 14 cn.lemon.{xxxx}.task 提供任务定时执行逻辑","categories":[{"name":"开源文档","slug":"开源文档","permalink":"https://github.com/lemon-china/categories/开源文档/"}],"tags":[{"name":"cloud","slug":"cloud","permalink":"https://github.com/lemon-china/tags/cloud/"},{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"consul","slug":"consul","permalink":"https://github.com/lemon-china/tags/consul/"},{"name":"lemon","slug":"lemon","permalink":"https://github.com/lemon-china/tags/lemon/"}]},{"title":"服务开发核心思想","slug":"exp_1113","date":"2019-09-05T04:30:12.000Z","updated":"2019-09-07T11:38:52.865Z","comments":true,"path":"2019/09/05/exp_1113/","link":"","permalink":"https://github.com/lemon-china/2019/09/05/exp_1113/","excerpt":"","text":"保障服务可扩展性的七大原则1、按功能划分 2、水平切分 3、尽量避免事务 4、适当采用异步解耦 5、次流程改进为异步 6、虚拟化所有层次 7、适当使用缓存 服务拆分开发的四项原则1、先业务后技术，先逻辑后物理 2、奥卡姆剃刀：如无必须勿增实体 3、正交性：抽象出模块间无业务相关的重复代码 4、稳定性原则：服务的稳定性优先，通过拆分解耦 可参考的技术方案：接口化、消息队列、模块化、服务化、异步化","categories":[{"name":"经验分享","slug":"经验分享","permalink":"https://github.com/lemon-china/categories/经验分享/"}],"tags":[{"name":"cloud","slug":"cloud","permalink":"https://github.com/lemon-china/tags/cloud/"},{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"分布式","slug":"分布式","permalink":"https://github.com/lemon-china/tags/分布式/"}]},{"title":"XXL-JOB分布式任务快速入门","slug":"stu_1111","date":"2019-09-04T07:21:11.000Z","updated":"2019-09-07T13:07:34.938Z","comments":true,"path":"2019/09/04/stu_1111/","link":"","permalink":"https://github.com/lemon-china/2019/09/04/stu_1111/","excerpt":"","text":"XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 项目地址：xxl-job分布式任务调度平台 模块 调度中心 xxl-job-admin 公共依赖 xxl-job-core 任务执行器 opay-xxx 集群 调度中心集群 DB配置保持一致 登陆账号配置保持一致 集群机器时钟保持一致建议：推荐通过nginx为调度中心集群做负载均衡，分配域名 调度中心访问、执行器回调配置、调用API服务等操作均通过该域名进行。 执行器集群 执行器回调地址保持一致xxl.job.admin.addresses 执行器集群内AppName保持一致xxl.job.executor.appname​ 任务关键点 执行器 任务描述 路由策略 FIRST（第一个）固定选择第一个机器 LAST（最后一个）固定选择最后一个机器 ROUND（轮询） RANDOM（随机）随机选择在线的机器 CONSISTENT_HASH（一致性HASH）每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上 LEAST_FREQUENTLY_USED（最不经常使用）使用频率最低的机器优先被选举 LEAST_RECENTLY_USED（最近最久未使用）最久为使用的机器优先被选举 FAILOVER（故障转移）按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度 BUSYOVER（忙碌转移）按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度 SHARDING_BROADCAST(分片广播)广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数，可根据分片参数开发分片任务 Cron表达式 运行模式 BEAN GLUE JobHandler任务bean名称@JobHandler 阻塞策略 单机串行进入单机执行器后，进入FIFO队列并以串行方式运行 丢弃后续调度进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败 覆盖之前调度进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列 负责人 其他 子任务ID 超时时间 重试次数 报警邮件 任务参数 注意事项 日志文件目录需要权限默认 /data/applogs/xxl-job/jobhandler​ 设置日志保存天数xxl.job.executor.logretentiondays=-1 //大于3生效 执行日志需要通过 “XxlJobLogger.log” 打印执行日志 admin执行任务时报错 Communications link failure数据库链接地址加上 &amp;autoReconnect=true&amp;failOverReadOnly=false","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/lemon-china/categories/学习笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"},{"name":"开源工具","slug":"开源工具","permalink":"https://github.com/lemon-china/tags/开源工具/"},{"name":"定时任务","slug":"定时任务","permalink":"https://github.com/lemon-china/tags/定时任务/"}]},{"title":"XXL-JOB分布式任务调度平台","slug":"tool_1112","date":"2019-09-03T05:23:12.000Z","updated":"2019-09-07T13:07:38.251Z","comments":true,"path":"2019/09/03/tool_1112/","link":"","permalink":"https://github.com/lemon-china/2019/09/03/tool_1112/","excerpt":"","text":"XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。 项目地址：xxl-job分布式任务调度平台 简单：支持通过Web页面对任务进行CRUD操作，操作简单，一分钟上手； 动态：支持动态修改任务状态、启动/停止任务，以及终止运行中任务，即时生效； 调度中心HA（中心式）：调度采用中心式设计，“调度中心”自研调度组件并支持集群部署，可保证调度中心HA； 执行器HA（分布式）：任务分布式执行，任务”执行器”支持集群部署，可保证任务执行HA； 注册中心: 执行器会周期性自动注册任务, 调度中心将会自动发现注册的任务并触发执行。同时，也支持手动录入执行器地址； 弹性扩容缩容：一旦有新执行器机器上线或者下线，下次调度时将会重新分配任务； 路由策略：执行器集群部署时提供丰富的路由策略，包括：第一个、最后一个、轮询、随机、一致性HASH、最不经常使用、最近最久未使用、故障转移、忙碌转移等； 故障转移：任务路由策略选择”故障转移”情况下，如果执行器集群中某一台机器故障，将会自动Failover切换到一台正常的执行器发送调度请求。 阻塞处理策略：调度过于密集执行器来不及处理时的处理策略，策略包括：单机串行（默认）、丢弃后续调度、覆盖之前调度； 任务超时控制：支持自定义任务超时时间，任务运行超时将会主动中断任务； 任务失败重试：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；其中分片任务支持分片粒度的失败重试； 任务失败告警；默认提供邮件方式失败告警，同时预留扩展接口，可方便的扩展短信、钉钉等告警方式； 分片广播任务：执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发集群中所有执行器执行一次任务，可根据分片参数开发分片任务； 动态分片：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。 事件触发：除了”Cron方式”和”任务依赖方式”触发任务执行之外，支持基于事件的触发任务方式。调度中心提供触发任务单次执行的API服务，可根据业务事件灵活触发。 任务进度监控：支持实时监控任务进度； Rolling实时日志：支持在线查看调度结果，并且支持以Rolling方式实时查看执行器输出的完整的执行日志； GLUE：提供Web IDE，支持在线开发任务逻辑代码，动态发布，实时编译生效，省略部署上线的过程。支持30个版本的历史版本回溯。 脚本任务：支持以GLUE模式开发和运行脚本任务，包括Shell、Python、NodeJS、PHP、PowerShell等类型脚本; 命令行任务：原生提供通用命令行任务Handler（Bean任务，”CommandJobHandler”）；业务方只需要提供命令行即可； 任务依赖：支持配置子任务依赖，当父任务执行结束且执行成功后将会主动触发一次子任务的执行, 多个子任务用逗号分隔； 一致性：“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行； 自定义任务参数：支持在线配置调度任务入参，即时生效； 调度线程池：调度系统多线程触发调度运行，确保调度精确执行，不被堵塞； 数据加密：调度中心和执行器之间的通讯进行数据加密，提升调度信息安全性； 邮件报警：任务失败时支持邮件报警，支持配置多邮件地址群发报警邮件； 推送maven中央仓库: 将会把最新稳定版推送到maven中央仓库, 方便用户接入和使用; 运行报表：支持实时查看运行数据，如任务数量、调度次数、执行器数量等；以及调度报表，如调度日期分布图，调度成功分布图等； 全异步：任务调度流程全异步化设计实现，如异步调度、异步运行、异步回调等，有效对密集调度进行流量削峰，理论上支持任意时长任务的运行； 跨平台：原生提供通用HTTP任务Handler（Bean任务，”HttpJobHandler”）；业务方只需要提供HTTP链接即可，不限制语言、平台； 国际化：调度中心支持国际化设置，提供中文、英文两种可选语言，默认为中文； 容器化：提供官方docker镜像，并实时更新推送dockerhub，进一步实现产品开箱即用； 线程池隔离：调度线程池进行隔离拆分，慢任务自动降级进入”Slow”线程池，避免耗尽调度线程，提高系统稳定性； 用户管理：支持在线管理系统用户，存在管理员、普通用户两种角色； 权限控制：执行器维度进行权限控制，管理员拥有全量权限，普通用户需要分配执行器权限后才允许相关操作。","categories":[{"name":"常用工具","slug":"常用工具","permalink":"https://github.com/lemon-china/categories/常用工具/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"},{"name":"开源工具","slug":"开源工具","permalink":"https://github.com/lemon-china/tags/开源工具/"},{"name":"定时任务","slug":"定时任务","permalink":"https://github.com/lemon-china/tags/定时任务/"}]},{"title":"代码习惯在细节","slug":"exp_1112","date":"2019-09-02T07:12:12.000Z","updated":"2019-09-07T07:38:18.422Z","comments":true,"path":"2019/09/02/exp_1112/","link":"","permalink":"https://github.com/lemon-china/2019/09/02/exp_1112/","excerpt":"","text":"分布式服务框架维护人员增多或变更，会出现质量的下降的问题，尤其是框架代码，要时刻牢记的细节。可能下面要讲的这些，大家都会觉得很简单，很基础，但要做到时刻牢记。在每一行代码中都考虑这些因素，是需要很大耐心的。 防止空指针和下标越界这是我最不喜欢看到的异常，尤其在核心框架中，我更愿看到信息详细的参数不合法异常。这也是一个编写健壮程序的开发人员，在写每一行代码都应在潜意识中防止的异常。基本上要能确保每一次写完的代码，在不测试的情况下，都不会出现这两个异常才算合格。 保证线程安全性和可见性对于框架的开发人员，对线程安全性和可见性的深入理解是最基本的要求。需要开发人员，在写每一行代码时都应在潜意识中确保其正确性。因为这种代码，在小并发下做功能测试时，会显得很正常。但在高并发下就会出现莫明其妙的问题，而且场景很难重现，极难排查。 尽早失败和前置断言尽早失败也应该成为潜意识，在有传入参数和状态变化时，均在入口处全部断言。一个不合法的值和状态，在第一时间就应报错，而不是等到要用时才报错。因为等到要用时，可能前面已经修改其它相关状态，而在程序中很少有人去处理回滚逻辑。这样报错后，其实内部状态可能已经混乱，极易在一个隐蔽分支上引发程序不可恢复。 分离可靠操作和不可靠操作这里的可靠是狭义的指是否会抛出异常或引起状态不一致，比如，写入一个线程安全的 Map，可以认为是可靠的，而写入数据库等，可以认为是不可靠的。开发人员必须在写每一行代码时，都注意它的可靠性与否，在代码中尽量划分开，并对失败做异常处理，并为容错，自我保护，自动恢复或切换等补偿逻辑提供清晰的切入点，保证后续增加的代码不至于放错位置，而导致原先的容错处理陷入混乱。 异常防御，但不忽略异常这里讲的异常防御，指的是对非必须途径上的代码进行最大限度的容忍，包括程序上的 BUG，比如：获取程序的版本号，会通过扫描 Manifest 和 jar 包名称抓取版本号，这个逻辑是辅助性的，但代码却不少，初步测试也没啥问题，但应该在整个 getVersion() 中加上一个全函数的 try-catch 打印错误日志，并返回基本版本，因为 getVersion() 可能存在未知特定场景异常，或被其他的开发人员误修改逻辑(但一般人员不会去掉 try-catch)，而如果它抛出异常会导致主流程异常，这是我们不希望看到的。但这里要控制个度，不要随意 try-catch，更不要无声无息的吃掉异常。 缩小可变域和尽量 final如果一个类可以成为不变类(Immutable Class)，就优先将它设计成不变类。不变类有天然的并发共享优势，减少同步或复制，而且可以有效帮忙分析线程安全的范围。就算是可变类，对于从构造函数传入的引用，在类中持有时，最好将字段 final，以免被中途误修改引用。不要以为这个字段是私有的，这个类的代码都是我自己写的，不会出现对这个字段的重新赋值。要考虑的一个因素是，这个代码可能被其他人修改，他不知道你的这个弱约定，final 就是一个不变契约。 降低修改时的误解性，不埋雷前面不停的提到代码被其他人修改，这也开发人员要随时紧记的。这个其他人包括未来的自己，你要总想着这个代码可能会有人去改它。我应该给修改的人一点什么提示，让他知道我现在的设计意图，而不要在程序里面加潜规则，或埋一些容易忽视的雷，比如：你用 null 表示不可用，size 等于 0 表示黑名单，这就是一个雷，下一个修改者，包括你自己，都不会记得有这样的约定，可能后面为了改某个其它 BUG，不小心改到了这里，直接引爆故障。对于这个例子，一个原则就是永远不要区分 null 引用和 empty 值。 提高代码的可测性这里的可测性主要指 Mock 的容易程度，和测试的隔离性。至于测试的自动性，可重复性，非偶然性，无序性，完备性(全覆盖)，轻量性(可快速执行)，一般开发人员，加上 JUnit 等工具的辅助基本都能做到，也能理解它的好处，只是工作量问题。这里要特别强调的是测试用例的单一性(只测目标类本身)和隔离性(不传染失败)。现在的测试代码，过于强调完备性，大量重复交叉测试，看起来没啥坏处，但测试代码越多，维护代价越高。经常出现的问题是，修改一行代码或加一个判断条件，引起 100 多个测试用例不通过。时间一紧，谁有这个闲功夫去改这么多形态各异的测试用例？久而久之，这个测试代码就已经不能真实反应代码现在的状况，很多时候会被迫绕过。最好的情况是，修改一行代码，有且只有一行测试代码不通过。如果修改了代码而测试用例还能通过，那也不行，表示测试没有覆盖到。另外，可 Mock 性是隔离的基础，把间接依赖的逻辑屏蔽掉。可 Mock 性的一个最大的杀手就是静态方法，尽量少用。","categories":[{"name":"经验分享","slug":"经验分享","permalink":"https://github.com/lemon-china/categories/经验分享/"}],"tags":[{"name":"cloud","slug":"cloud","permalink":"https://github.com/lemon-china/tags/cloud/"},{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"分布式","slug":"分布式","permalink":"https://github.com/lemon-china/tags/分布式/"}]},{"title":"Apollo分布式配置中心快速入门","slug":"stu_1112","date":"2019-09-02T04:21:22.000Z","updated":"2019-09-07T13:31:36.409Z","comments":true,"path":"2019/09/02/stu_1112/","link":"","permalink":"https://github.com/lemon-china/2019/09/02/stu_1112/","excerpt":"","text":"Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。 项目地址：apollo分布式配置中心 关键词 AppId ENV Cluster Namespace Public Private 关联(继承) 操作点 发布 回滚 灰度 创建Cluster 创建/关联Namespace 核心点 项目AppId 宿主机ENV apollo.meta Private AppId Public Share 可多Namespace Public关联 / 覆盖","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/lemon-china/categories/学习笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"},{"name":"开源工具","slug":"开源工具","permalink":"https://github.com/lemon-china/tags/开源工具/"},{"name":"定时任务","slug":"定时任务","permalink":"https://github.com/lemon-china/tags/定时任务/"},{"name":"apollo","slug":"apollo","permalink":"https://github.com/lemon-china/tags/apollo/"}]},{"title":"乐檬框架之rabbitMQ的解耦实现方式","slug":"doc_1111","date":"2019-09-02T02:34:12.000Z","updated":"2019-09-07T13:25:31.189Z","comments":true,"path":"2019/09/02/doc_1111/","link":"","permalink":"https://github.com/lemon-china/2019/09/02/doc_1111/","excerpt":"","text":"项目地址：lemon-rabbitmq lemon-rabbitmq 消息生产端 lemon-rabbitmq-protocol 消息协议层 lemon-rabbitmq-consumer 消息消费端 消息协议层通过Jackson2序列化/反序列化，实现消息传递和对象接收 消息生产端1、通过发送带有消费端服务类名称和方法请求头，控制消费端调用执行消费发送的信息 2、利用消息回调接口ConfirmCallback确保消息安全发送至broker服务器，处理效率比事物方式更高 1234567891011121314151617public void sendMessage(final String serviceName, final String serviceMethodName,final String correlationId, Object request) &#123; logger.info(\"sendMessage [this.&#123;&#125;, serviceMethodName:&#123;&#125; serviceName:&#123;&#125; correlationId: &#123;&#125;]\", this.getClass(), serviceMethodName, serviceName, correlationId); rabbitTemplate.setConfirmCallback(this); rabbitTemplate.setCorrelationKey(correlationId); rabbitTemplate.convertAndSend(routingkey, request, new MessagePostProcessor() &#123; @Override public Message postProcessMessage(Message message) throws AmqpException &#123; message.getMessageProperties().setAppId(appId); message.getMessageProperties().setTimestamp(new Date()); message.getMessageProperties().setMessageId(UUID.randomUUID().toString()); message.getMessageProperties().setCorrelationId(correlationId.getBytes()); message.getMessageProperties().setHeader(\"ServiceMethodName\", serviceMethodName); message.getMessageProperties().setHeader(\"ServiceName\", serviceName); return message; &#125; &#125;, new CorrelationData(correlationId));&#125; 消息消费端1、监听MQ消息，利用method.invoke调用指定的服务类名称和方法，消费接收到的消息 2、使用Ack/Nack手动确认消息处理状态，保证broker消息被正确消费 12345678910111213141516171819public void onMessage(Message message, Channel channel) throws IOException &#123; System.out.println(\"----- received\" + message.getMessageProperties()); try &#123; Object msg = messageConverter.fromMessage(message); if (!appId.equals(message.getMessageProperties().getAppId()))&#123; channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); throw new SecurityException(\"非法应用appId:\" + message.getMessageProperties().getAppId()); &#125; Object service = ctx.getBean(message.getMessageProperties().getHeaders().get(\"ServiceName\").toString()); String serviceMethodName = message.getMessageProperties().getHeaders().get(\"ServiceMethodName\").toString(); Method method = service.getClass().getMethod(serviceMethodName, msg.getClass()); method.invoke(service, msg); //确认消息成功消费 channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); &#125; catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123; System.out.println(\"------ err\"+ e.getMessage()); channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); &#125;&#125;","categories":[{"name":"开源文档","slug":"开源文档","permalink":"https://github.com/lemon-china/categories/开源文档/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"},{"name":"mq","slug":"mq","permalink":"https://github.com/lemon-china/tags/mq/"},{"name":"ack/nack","slug":"ack-nack","permalink":"https://github.com/lemon-china/tags/ack-nack/"}]},{"title":"Hutool工具包类库","slug":"tool_1111","date":"2019-09-01T12:33:12.000Z","updated":"2019-09-07T13:07:45.443Z","comments":true,"path":"2019/09/01/tool_1111/","link":"","permalink":"https://github.com/lemon-china/2019/09/01/tool_1111/","excerpt":"","text":"Hutool是一个Java工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让Java语言也可以“甜甜的”。Hutool最初是我项目中“util”包的一个整理，后来慢慢积累并加入更多非业务相关功能，并广泛学习其它开源项目精髓，经过自己整理修改，最终形成丰富的开源工具集。 项目地址：hutool工具包 日期工具通过DateUtil类，提供高度便捷的日期访问、处理和转换方式。 HTTP客户端通过HttpUtil对HTTP客户端的封装，实现便捷的HTTP请求，并简化文件上传操作。 转换工具通过Convert类中的相应静态方法，提供一整套的类型转换解决方案，并通过ConverterRegistry工厂类自定义转换。 配置文件工具通过Setting对象，提供兼容Properties文件的更加强大的配置文件工具，用于解决中文、分组等JDK配置文件存在的诸多问题。 日志工具Hutool的日志功能，通过抽象Log接口，提供对Slf4j、LogBack、Log4j、JDK-Logging的全面兼容支持。 JDBC工具类通过db模块，提供对MySQL、Oracle等关系型数据库的JDBC封装，借助ActiveRecord思想，大大简化数据库操作。","categories":[{"name":"常用工具","slug":"常用工具","permalink":"https://github.com/lemon-china/categories/常用工具/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"},{"name":"开源工具","slug":"开源工具","permalink":"https://github.com/lemon-china/tags/开源工具/"},{"name":"spring","slug":"spring","permalink":"https://github.com/lemon-china/tags/spring/"}]},{"title":"基于consul注册中心实现cloud微服务框架","slug":"exp_1111","date":"2019-09-01T02:10:12.000Z","updated":"2019-09-07T07:38:14.897Z","comments":true,"path":"2019/09/01/exp_1111/","link":"","permalink":"https://github.com/lemon-china/2019/09/01/exp_1111/","excerpt":"","text":"基于consul注册中心实现微服务框架，使用consul替代eureka和git config模式 本项目预启动时间为2019-03-01，实现以下内容： 开发计划v0.1版本 整体服务结构划分，服务边界设定v0.2版本 服务网关授权模式搭建v0.3版本 前后端技术框架接入v0.4版本 服务开发技术规范文档v0.5版本 用户基础服务功能 服务架构总览center 服务综合管理中心 &ensp;|— lemon-gateway 服务网关 &ensp;|— lemon-monitor 服务监控 &ensp;| commons 服务基础组件中心 &ensp;|— lemon-common 服务通用组件 &ensp;|— lemon-distribution 分布业务锁&amp;任务锁 &ensp;|— lemon-framework 服务基础功能类包 &ensp;|— lemon-rabbit 服务Rabbit功能统一封装组件 &ensp;|— lemon-sharding 数据库分库分表封装组件 services 微服务中心 &ensp;|— lemon-auth 授权&amp;鉴权服务 &ensp;|— lemon-user 用户服务 &ensp;|— lemon-xxx &ensp;| 服务项目结构约定1、服务名由lemon-{xxxx}组成，xxxx为相关微服务的业务名称 2、每个服务脚手架组件包含如下： NO. Package Desc 1 cn.lemon.{xxxx}.api.rest 提供对外服务rest接口 2 cn.lemon.{xxxx}.api.rpc 提供对内服务rpc接口 3 cn.lemon.{xxxx}.config 提供服务配置相关 4 cn.lemon.{xxxx}.entity.enums 提供业务枚举类 5 cn.lemon.{xxxx}.entity.po 提供数据库映射实体 6 cn.lemon.{xxxx}.entity.vo 提供对外接口映射实体 7 cn.lemon.{xxxx}.rpc.client 提供对内服务rpc调用接口 (api层不能调用rpc接口) 8 cn.lemon.{xxxx}.rpc.client.fallback 提供对内服务rpc调用失败业务处理 9 cn.lemon.{xxxx}.service 提供业务逻辑接口 (api层调用业务接口) 10 cn.lemon.{xxxx}.service.impl 提供业务逻辑实现 11 cn.lemon.{xxxx}.dao 提供数据库操作 12 cn.lemon.{xxxx}.events.pub 提供MQ发送事件 13 cn.lemon.{xxxx}.events.sub 提供MQ接收事件 14 cn.lemon.{xxxx}.task 提供任务定时执行逻辑","categories":[{"name":"经验分享","slug":"经验分享","permalink":"https://github.com/lemon-china/categories/经验分享/"}],"tags":[{"name":"cloud","slug":"cloud","permalink":"https://github.com/lemon-china/tags/cloud/"},{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"consul","slug":"consul","permalink":"https://github.com/lemon-china/tags/consul/"},{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"}]}]}