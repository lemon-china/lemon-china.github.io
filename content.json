{"meta":{"title":"lemon-china","subtitle":"乐檬·中国致力于打造最优雅的系统框架","description":null,"author":"lemon-china","url":"https://github.com/lemon-china","root":"/"},"pages":[{"title":"文章分类","date":"2019-09-07T06:11:44.000Z","updated":"2019-09-07T06:58:51.580Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/lemon-china/categories/index.html","excerpt":"","text":""},{"title":"文章标签","date":"2019-09-07T06:20:06.000Z","updated":"2019-09-07T06:59:09.130Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/lemon-china/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-09-07T03:53:31.000Z","updated":"2019-09-07T06:20:18.596Z","comments":true,"path":"links/index.html","permalink":"https://github.com/lemon-china/links/index.html","excerpt":"","text":"柴伙二维码平台"},{"title":"archives","date":"2019-09-07T02:43:41.000Z","updated":"2019-09-07T03:13:50.272Z","comments":true,"path":"archives/index.html","permalink":"https://github.com/lemon-china/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"服务开发核心思想","slug":"cloud-mind","date":"2019-09-05T04:30:12.000Z","updated":"2019-09-07T05:48:40.352Z","comments":true,"path":"2019/09/05/cloud-mind/","link":"","permalink":"https://github.com/lemon-china/2019/09/05/cloud-mind/","excerpt":"","text":"保障服务可扩展性的七大原则1、按功能划分 2、水平切分 3、尽量避免事务 4、适当采用异步解耦 5、次流程改进为异步 6、虚拟化所有层次 7、适当使用缓存 服务拆分开发的四项原则1、先业务后技术，先逻辑后物理 2、奥卡姆剃刀：如无必须勿增实体 3、正交性：抽象出模块间无业务相关的重复代码 4、稳定性原则：服务的稳定性优先，通过拆分解耦 PS: 可参考的技术方案：接口化、消息队列、模块化、服务化、异步化","categories":[{"name":"技术规范","slug":"技术规范","permalink":"https://github.com/lemon-china/categories/技术规范/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"cloud","slug":"cloud","permalink":"https://github.com/lemon-china/tags/cloud/"},{"name":"分布式","slug":"分布式","permalink":"https://github.com/lemon-china/tags/分布式/"}]},{"title":"代码习惯在细节","slug":"cloud-rule","date":"2019-09-02T07:12:12.000Z","updated":"2019-09-07T05:34:44.696Z","comments":true,"path":"2019/09/02/cloud-rule/","link":"","permalink":"https://github.com/lemon-china/2019/09/02/cloud-rule/","excerpt":"","text":"分布式服务框架维护人员增多或变更，会出现质量的下降的问题，尤其是框架代码，要时刻牢记的细节。可能下面要讲的这些，大家都会觉得很简单，很基础，但要做到时刻牢记。在每一行代码中都考虑这些因素，是需要很大耐心的。 防止空指针和下标越界这是我最不喜欢看到的异常，尤其在核心框架中，我更愿看到信息详细的参数不合法异常。这也是一个编写健壮程序的开发人员，在写每一行代码都应在潜意识中防止的异常。基本上要能确保每一次写完的代码，在不测试的情况下，都不会出现这两个异常才算合格。 保证线程安全性和可见性对于框架的开发人员，对线程安全性和可见性的深入理解是最基本的要求。需要开发人员，在写每一行代码时都应在潜意识中确保其正确性。因为这种代码，在小并发下做功能测试时，会显得很正常。但在高并发下就会出现莫明其妙的问题，而且场景很难重现，极难排查。 尽早失败和前置断言尽早失败也应该成为潜意识，在有传入参数和状态变化时，均在入口处全部断言。一个不合法的值和状态，在第一时间就应报错，而不是等到要用时才报错。因为等到要用时，可能前面已经修改其它相关状态，而在程序中很少有人去处理回滚逻辑。这样报错后，其实内部状态可能已经混乱，极易在一个隐蔽分支上引发程序不可恢复。 分离可靠操作和不可靠操作这里的可靠是狭义的指是否会抛出异常或引起状态不一致，比如，写入一个线程安全的 Map，可以认为是可靠的，而写入数据库等，可以认为是不可靠的。开发人员必须在写每一行代码时，都注意它的可靠性与否，在代码中尽量划分开，并对失败做异常处理，并为容错，自我保护，自动恢复或切换等补偿逻辑提供清晰的切入点，保证后续增加的代码不至于放错位置，而导致原先的容错处理陷入混乱。 异常防御，但不忽略异常这里讲的异常防御，指的是对非必须途径上的代码进行最大限度的容忍，包括程序上的 BUG，比如：获取程序的版本号，会通过扫描 Manifest 和 jar 包名称抓取版本号，这个逻辑是辅助性的，但代码却不少，初步测试也没啥问题，但应该在整个 getVersion() 中加上一个全函数的 try-catch 打印错误日志，并返回基本版本，因为 getVersion() 可能存在未知特定场景异常，或被其他的开发人员误修改逻辑(但一般人员不会去掉 try-catch)，而如果它抛出异常会导致主流程异常，这是我们不希望看到的。但这里要控制个度，不要随意 try-catch，更不要无声无息的吃掉异常。 缩小可变域和尽量 final如果一个类可以成为不变类(Immutable Class)，就优先将它设计成不变类。不变类有天然的并发共享优势，减少同步或复制，而且可以有效帮忙分析线程安全的范围。就算是可变类，对于从构造函数传入的引用，在类中持有时，最好将字段 final，以免被中途误修改引用。不要以为这个字段是私有的，这个类的代码都是我自己写的，不会出现对这个字段的重新赋值。要考虑的一个因素是，这个代码可能被其他人修改，他不知道你的这个弱约定，final 就是一个不变契约。 降低修改时的误解性，不埋雷前面不停的提到代码被其他人修改，这也开发人员要随时紧记的。这个其他人包括未来的自己，你要总想着这个代码可能会有人去改它。我应该给修改的人一点什么提示，让他知道我现在的设计意图，而不要在程序里面加潜规则，或埋一些容易忽视的雷，比如：你用 null 表示不可用，size 等于 0 表示黑名单，这就是一个雷，下一个修改者，包括你自己，都不会记得有这样的约定，可能后面为了改某个其它 BUG，不小心改到了这里，直接引爆故障。对于这个例子，一个原则就是永远不要区分 null 引用和 empty 值。 提高代码的可测性这里的可测性主要指 Mock 的容易程度，和测试的隔离性。至于测试的自动性，可重复性，非偶然性，无序性，完备性(全覆盖)，轻量性(可快速执行)，一般开发人员，加上 JUnit 等工具的辅助基本都能做到，也能理解它的好处，只是工作量问题。这里要特别强调的是测试用例的单一性(只测目标类本身)和隔离性(不传染失败)。现在的测试代码，过于强调完备性，大量重复交叉测试，看起来没啥坏处，但测试代码越多，维护代价越高。经常出现的问题是，修改一行代码或加一个判断条件，引起 100 多个测试用例不通过。时间一紧，谁有这个闲功夫去改这么多形态各异的测试用例？久而久之，这个测试代码就已经不能真实反应代码现在的状况，很多时候会被迫绕过。最好的情况是，修改一行代码，有且只有一行测试代码不通过。如果修改了代码而测试用例还能通过，那也不行，表示测试没有覆盖到。另外，可 Mock 性是隔离的基础，把间接依赖的逻辑屏蔽掉。可 Mock 性的一个最大的杀手就是静态方法，尽量少用。","categories":[{"name":"技术规范","slug":"技术规范","permalink":"https://github.com/lemon-china/categories/技术规范/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"cloud","slug":"cloud","permalink":"https://github.com/lemon-china/tags/cloud/"},{"name":"分布式","slug":"分布式","permalink":"https://github.com/lemon-china/tags/分布式/"}]},{"title":"基于consul注册中心实现cloud微服务框架","slug":"cloud-guid","date":"2019-09-01T02:10:12.000Z","updated":"2019-09-07T05:18:18.458Z","comments":true,"path":"2019/09/01/cloud-guid/","link":"","permalink":"https://github.com/lemon-china/2019/09/01/cloud-guid/","excerpt":"","text":"基于consul注册中心实现微服务框架，使用consul替代eureka和git config模式 本项目预启动时间为2019-03-01，实现以下内容： 开发计划v0.1版本 整体服务结构划分，服务边界设定v0.2版本 服务网关授权模式搭建v0.3版本 前后端技术框架接入v0.4版本 服务开发技术规范文档v0.5版本 用户基础服务功能 服务架构总览center 服务综合管理中心 &ensp;|— lemon-gateway 服务网关 &ensp;|— lemon-monitor 服务监控 &ensp;| commons 服务基础组件中心 &ensp;|— lemon-common 服务通用组件 &ensp;|— lemon-distribution 分布业务锁&amp;任务锁 &ensp;|— lemon-framework 服务基础功能类包 &ensp;|— lemon-rabbit 服务Rabbit功能统一封装组件 &ensp;|— lemon-sharding 数据库分库分表封装组件 services 微服务中心 &ensp;|— lemon-auth 授权&amp;鉴权服务 &ensp;|— lemon-user 用户服务 &ensp;|— lemon-xxx &ensp;| 服务项目结构约定1、服务名由lemon-{xxxx}组成，xxxx为相关微服务的业务名称 2、每个服务脚手架组件包含如下： NO. Package Desc 1 cn.lemon.{xxxx}.api.rest 提供对外服务rest接口 2 cn.lemon.{xxxx}.api.rpc 提供对内服务rpc接口 3 cn.lemon.{xxxx}.config 提供服务配置相关 4 cn.lemon.{xxxx}.entity.enums 提供业务枚举类 5 cn.lemon.{xxxx}.entity.po 提供数据库映射实体 6 cn.lemon.{xxxx}.entity.vo 提供对外接口映射实体 7 cn.lemon.{xxxx}.rpc.client 提供对内服务rpc调用接口 (api层不能调用rpc接口) 8 cn.lemon.{xxxx}.rpc.client.fallback 提供对内服务rpc调用失败业务处理 9 cn.lemon.{xxxx}.service 提供业务逻辑接口 (api层调用业务接口) 10 cn.lemon.{xxxx}.service.impl 提供业务逻辑实现 11 cn.lemon.{xxxx}.dao 提供数据库操作 12 cn.lemon.{xxxx}.events.pub 提供MQ发送事件 13 cn.lemon.{xxxx}.events.sub 提供MQ接收事件 14 cn.lemon.{xxxx}.task 提供任务定时执行逻辑","categories":[{"name":"技术架构","slug":"技术架构","permalink":"https://github.com/lemon-china/categories/技术架构/"}],"tags":[{"name":"consul","slug":"consul","permalink":"https://github.com/lemon-china/tags/consul/"},{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"cloud","slug":"cloud","permalink":"https://github.com/lemon-china/tags/cloud/"},{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"}]},{"title":"乐檬框架之rabbitMQ的解耦实现方式（基于springboot框架）","slug":"lemon-rabbitmq","date":"2017-05-01T02:34:12.000Z","updated":"2019-09-07T05:18:23.846Z","comments":true,"path":"2017/05/01/lemon-rabbitmq/","link":"","permalink":"https://github.com/lemon-china/2017/05/01/lemon-rabbitmq/","excerpt":"","text":"项目地址：lemon-rabbitmq lemon-rabbitmq 消息生产端 lemon-rabbitmq-protocol 消息协议层 lemon-rabbitmq-consumer 消息消费端 消息协议层通过Jackson2序列化/反序列化，实现消息传递和对象接收 消息生产端1、通过发送带有消费端服务类名称和方法请求头，控制消费端调用执行消费发送的信息 2、利用消息回调接口ConfirmCallback确保消息安全发送至broker服务器，处理效率比事物方式更高 1234567891011121314151617public void sendMessage(final String serviceName, final String serviceMethodName,final String correlationId, Object request) &#123; logger.info(\"sendMessage [this.&#123;&#125;, serviceMethodName:&#123;&#125; serviceName:&#123;&#125; correlationId: &#123;&#125;]\", this.getClass(), serviceMethodName, serviceName, correlationId); rabbitTemplate.setConfirmCallback(this); rabbitTemplate.setCorrelationKey(correlationId); rabbitTemplate.convertAndSend(routingkey, request, new MessagePostProcessor() &#123; @Override public Message postProcessMessage(Message message) throws AmqpException &#123; message.getMessageProperties().setAppId(appId); message.getMessageProperties().setTimestamp(new Date()); message.getMessageProperties().setMessageId(UUID.randomUUID().toString()); message.getMessageProperties().setCorrelationId(correlationId.getBytes()); message.getMessageProperties().setHeader(\"ServiceMethodName\", serviceMethodName); message.getMessageProperties().setHeader(\"ServiceName\", serviceName); return message; &#125; &#125;, new CorrelationData(correlationId));&#125; 消息消费端1、监听MQ消息，利用method.invoke调用指定的服务类名称和方法，消费接收到的消息 2、使用Ack/Nack手动确认消息处理状态，保证broker消息被正确消费 12345678910111213141516171819public void onMessage(Message message, Channel channel) throws IOException &#123; System.out.println(\"----- received\" + message.getMessageProperties()); try &#123; Object msg = messageConverter.fromMessage(message); if (!appId.equals(message.getMessageProperties().getAppId()))&#123; channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); throw new SecurityException(\"非法应用appId:\" + message.getMessageProperties().getAppId()); &#125; Object service = ctx.getBean(message.getMessageProperties().getHeaders().get(\"ServiceName\").toString()); String serviceMethodName = message.getMessageProperties().getHeaders().get(\"ServiceMethodName\").toString(); Method method = service.getClass().getMethod(serviceMethodName, msg.getClass()); method.invoke(service, msg); //确认消息成功消费 channel.basicAck(message.getMessageProperties().getDeliveryTag(), false); &#125; catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123; System.out.println(\"------ err\"+ e.getMessage()); channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); &#125;&#125;","categories":[{"name":"技术架构","slug":"技术架构","permalink":"https://github.com/lemon-china/categories/技术架构/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"https://github.com/lemon-china/tags/springboot/"},{"name":"java","slug":"java","permalink":"https://github.com/lemon-china/tags/java/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://github.com/lemon-china/tags/rabbitmq/"},{"name":"ack/nack","slug":"ack-nack","permalink":"https://github.com/lemon-china/tags/ack-nack/"}]}]}